diff -r 55f6804b4352 src/share/classes/java/lang/Iterable.java
--- a/src/share/classes/java/lang/Iterable.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/lang/Iterable.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,9 +23,9 @@
  * questions.
  */

-package java.lang;
+package org.jvnet.zephyr.jcl.java.lang;

-import java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Iterator;

 /**
  * Implementing this interface allows an object to be the target of
diff -r 55f6804b4352 src/share/classes/java/lang/SecurityManager.java
--- a/src/share/classes/java/lang/SecurityManager.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/lang/SecurityManager.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,24 +23,23 @@
  * questions.
  */

-package java.lang;
+package org.jvnet.zephyr.jcl.java.lang;

-import java.security.*;
+import org.jvnet.zephyr.jcl.impl.misc.ReflectionUtils;
+import sun.security.util.SecurityConstants;
+
+import java.io.File;
 import java.io.FileDescriptor;
-import java.io.File;
 import java.io.FilePermission;
-import java.awt.AWTPermission;
+import java.lang.reflect.Member;
+import java.net.InetAddress;
+import java.net.SocketPermission;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.Permission;
+import java.security.PrivilegedAction;
+import java.security.SecurityPermission;
 import java.util.PropertyPermission;
-import java.lang.RuntimePermission;
-import java.net.SocketPermission;
-import java.net.NetPermission;
-import java.util.Hashtable;
-import java.net.InetAddress;
-import java.lang.reflect.Member;
-import java.lang.reflect.*;
-import java.net.URL;
-
-import sun.security.util.SecurityConstants;

 /**
  * The security manager is a class that allows
@@ -202,10 +201,10 @@
  *
  * @see     java.lang.ClassLoader
  * @see     java.lang.SecurityException
- * @see     java.lang.SecurityManager#checkTopLevelWindow(java.lang.Object)
+ * @see     SecurityManager#checkTopLevelWindow(java.lang.Object)
  *  checkTopLevelWindow
- * @see     java.lang.System#getSecurityManager() getSecurityManager
- * @see     java.lang.System#setSecurityManager(java.lang.SecurityManager)
+ * @see     System#getSecurityManager() getSecurityManager
+ * @see     System#setSecurityManager(SecurityManager)
  *  setSecurityManager
  * @see     java.security.AccessController AccessController
  * @see     java.security.AccessControlContext AccessControlContext
@@ -263,7 +262,7 @@
      *          should contain <code>true</code> if a security check is
      *          in progress,
      *          <code>false</code> otherwise.
-     * @see     java.lang.SecurityManager#inCheck
+     * @see     SecurityManager#inCheck
      * @deprecated This type of security checking is not recommended.
      *  It is recommended that the <code>checkPermission</code>
      *  call be used instead.
@@ -286,7 +285,7 @@
      * @exception  java.lang.SecurityException if a security manager already
      *             exists and its <code>checkPermission</code> method
      *             doesn't allow creation of a new security manager.
-     * @see        java.lang.System#getSecurityManager()
+     * @see        System#getSecurityManager()
      * @see        #checkPermission(java.security.Permission) checkPermission
      * @see java.lang.RuntimePermission
      */
@@ -313,7 +312,9 @@
      *
      * @return  the execution stack.
      */
-    protected native Class[] getClassContext();
+    protected Class[] getClassContext() {
+        return ReflectionUtils.getClassContext();
+    }

     /**
      * Returns the class loader of the most recently executing method from
@@ -360,7 +361,9 @@
         return cl;
     }

-    private native ClassLoader currentClassLoader0();
+    private ClassLoader currentClassLoader0() {
+        return null;
+    }

     /**
      * Returns the class of the most recently executing method from
@@ -419,7 +422,9 @@
      *
      */
     @Deprecated
-    protected native int classDepth(String name);
+    protected int classDepth(String name) {
+        return -1;
+    }

     /**
      * Returns the stack depth of the most recently executing method
@@ -469,7 +474,9 @@
         return depth;
     }

-    private native int classLoaderDepth0();
+    private int classLoaderDepth0() {
+        return -1;
+    }

     /**
      * Tests if a method from a class with the specified
@@ -520,9 +527,9 @@
      * @return  an implementation-dependent object that encapsulates
      *          sufficient information about the current execution environment
      *          to perform some security checks later.
-     * @see     java.lang.SecurityManager#checkConnect(java.lang.String, int,
+     * @see     SecurityManager#checkConnect(java.lang.String, int,
      *   java.lang.Object) checkConnect
-     * @see     java.lang.SecurityManager#checkRead(java.lang.String,
+     * @see     SecurityManager#checkRead(java.lang.String,
      *   java.lang.Object) checkRead
      * @see     java.security.AccessControlContext AccessControlContext
      */
@@ -576,7 +583,7 @@
      *             resource specified by the given permission.
      * @exception  NullPointerException if the permission argument is
      *             <code>null</code>.
-     * @see        java.lang.SecurityManager#getSecurityContext()
+     * @see        SecurityManager#getSecurityContext()
      * @see java.security.AccessControlContext#checkPermission(java.security.Permission)
      * @since      1.2
      */
@@ -660,12 +667,12 @@
      *             permission to modify the thread.
      * @exception  NullPointerException if the thread argument is
      *             <code>null</code>.
-     * @see        java.lang.Thread#resume() resume
-     * @see        java.lang.Thread#setDaemon(boolean) setDaemon
-     * @see        java.lang.Thread#setName(java.lang.String) setName
-     * @see        java.lang.Thread#setPriority(int) setPriority
-     * @see        java.lang.Thread#stop() stop
-     * @see        java.lang.Thread#suspend() suspend
+     * @see        Thread#resume() resume
+     * @see        Thread#setDaemon(boolean) setDaemon
+     * @see        Thread#setName(java.lang.String) setName
+     * @see        Thread#setPriority(int) setPriority
+     * @see        Thread#stop() stop
+     * @see        Thread#suspend() suspend
      * @see        #checkPermission(java.security.Permission) checkPermission
      */
     public void checkAccess(Thread t) {
@@ -713,12 +720,12 @@
      *             permission to modify the thread group.
      * @exception  NullPointerException if the thread group argument is
      *             <code>null</code>.
-     * @see        java.lang.ThreadGroup#destroy() destroy
-     * @see        java.lang.ThreadGroup#resume() resume
-     * @see        java.lang.ThreadGroup#setDaemon(boolean) setDaemon
-     * @see        java.lang.ThreadGroup#setMaxPriority(int) setMaxPriority
-     * @see        java.lang.ThreadGroup#stop() stop
-     * @see        java.lang.ThreadGroup#suspend() suspend
+     * @see        ThreadGroup#destroy() destroy
+     * @see        ThreadGroup#resume() resume
+     * @see        ThreadGroup#setDaemon(boolean) setDaemon
+     * @see        ThreadGroup#setMaxPriority(int) setMaxPriority
+     * @see        ThreadGroup#stop() stop
+     * @see        ThreadGroup#suspend() suspend
      * @see        #checkPermission(java.security.Permission) checkPermission
      */
     public void checkAccess(ThreadGroup g) {
@@ -916,7 +923,7 @@
      *             to read the specified file.
      * @exception  NullPointerException if the <code>file</code> argument is
      *             <code>null</code>.
-     * @see        java.lang.SecurityManager#getSecurityContext()
+     * @see        SecurityManager#getSecurityContext()
      * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
      */
     public void checkRead(String file, Object context) {
@@ -1089,7 +1096,7 @@
      *             <code>host</code> and <code>port</code>.
      * @exception  NullPointerException if the <code>host</code> argument is
      *             <code>null</code>.
-     * @see        java.lang.SecurityManager#getSecurityContext()
+     * @see        SecurityManager#getSecurityContext()
      * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
      */
     public void checkConnect(String host, int port, Object context) {
@@ -1257,8 +1264,8 @@
      *
      * @exception  SecurityException  if the calling thread does not have
      *             permission to access or modify the system properties.
-     * @see        java.lang.System#getProperties()
-     * @see        java.lang.System#setProperties(java.util.Properties)
+     * @see        System#getProperties()
+     * @see        System#setProperties(java.util.Properties)
      * @see        #checkPermission(java.security.Permission) checkPermission
      */
     public void checkPropertiesAccess() {
@@ -1291,7 +1298,7 @@
      *             <code>null</code>.
      * @exception  IllegalArgumentException if <code>key</code> is empty.
      *
-     * @see        java.lang.System#getProperty(java.lang.String)
+     * @see        System#getProperty(java.lang.String)
      * @see        #checkPermission(java.security.Permission) checkPermission
      */
     public void checkPropertyAccess(String key) {
@@ -1711,7 +1718,9 @@
         checkPermission(new SecurityPermission(target));
     }

-    private native Class currentLoadedClass0();
+    private Class currentLoadedClass0() {
+        return null;
+    }

     /**
      * Returns the thread group into which to instantiate any new
@@ -1722,7 +1731,7 @@
      *
      * @return  ThreadGroup that new threads are instantiated into
      * @since   JDK1.1
-     * @see     java.lang.ThreadGroup
+     * @see     ThreadGroup
      */
     public ThreadGroup getThreadGroup() {
         return Thread.currentThread().getThreadGroup();
diff -r 55f6804b4352 src/share/classes/java/lang/System.java
--- a/src/share/classes/java/lang/System.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/lang/System.java	Fri Jul 31 15:48:18 2015 +0300
@@ -22,23 +22,29 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-package java.lang;
+package org.jvnet.zephyr.jcl.java.lang;

-import java.io.*;
-import java.security.AccessControlContext;
-import java.util.Properties;
-import java.util.PropertyPermission;
-import java.util.StringTokenizer;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;
+import org.jvnet.zephyr.jcl.java.util.AbstractMap;
+import org.jvnet.zephyr.jcl.java.util.AbstractSet;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Map;
+import org.jvnet.zephyr.jcl.java.util.Properties;
+import org.jvnet.zephyr.jcl.java.util.Set;
+import sun.misc.Unsafe;
+import sun.security.util.SecurityConstants;
+
+import java.io.Console;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PrintStream;
+import java.io.Serializable;
+import java.lang.reflect.Field;
+import java.nio.channels.Channel;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.security.AllPermission;
-import java.nio.channels.Channel;
-import java.nio.channels.spi.SelectorProvider;
-import sun.nio.ch.Interruptible;
-import sun.reflect.CallerSensitive;
-import sun.reflect.Reflection;
-import sun.security.util.SecurityConstants;
-import sun.reflect.annotation.AnnotationType;
+import java.util.PropertyPermission;

 /**
  * The <code>System</code> class contains several useful class fields
@@ -55,18 +61,6 @@
  */
 public final class System {

-    /* register the natives via the static initializer.
-     *
-     * VM will invoke the initializeSystemClass method to complete
-     * the initialization for this class separated from clinit.
-     * Note that to use properties set by the VM, see the constraints
-     * described in the initializeSystemClass method.
-     */
-    private static native void registerNatives();
-    static {
-        registerNatives();
-    }
-
     /** Don't let anyone instantiate this class */
     private System() {
     }
@@ -197,7 +191,6 @@
         setErr0(err);
     }

-    private static volatile Console cons = null;
     /**
      * Returns the unique {@link java.io.Console Console} object associated
      * with the current Java virtual machine, if any.
@@ -207,12 +200,7 @@
      * @since   1.6
      */
      public static Console console() {
-         if (cons == null) {
-             synchronized (System.class) {
-                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();
-             }
-         }
-         return cons;
+         return java.lang.System.console();
      }

     /**
@@ -220,12 +208,12 @@
      * Java virtual machine.
      *
      * <p> This method returns the channel obtained by invoking the
-     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel
+     * {@link SelectorProvider#inheritedChannel
      * inheritedChannel} method of the system-wide default
-     * {@link java.nio.channels.spi.SelectorProvider} object. </p>
+     * {@link SelectorProvider} object. </p>
      *
      * <p> In addition to the network-oriented channels described in
-     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel
+     * {@link SelectorProvider#inheritedChannel
      * inheritedChannel}, this method may return other kinds of
      * channels in the future.
      *
@@ -251,9 +239,17 @@
         }
     }

-    private static native void setIn0(InputStream in);
-    private static native void setOut0(PrintStream out);
-    private static native void setErr0(PrintStream err);
+    private static void setIn0(InputStream in) {
+        UNSAFE.putObject(IN_BASE, IN_OFFSET, in);
+    }
+
+    private static void setOut0(PrintStream out) {
+        UNSAFE.putObject(OUT_BASE, OUT_OFFSET, out);
+    }
+
+    private static void setErr0(PrintStream err) {
+        UNSAFE.putObject(ERR_BASE, ERR_OFFSET, err);
+    }

     /**
      * Sets the System security.
@@ -347,7 +343,9 @@
      *          the current time and midnight, January 1, 1970 UTC.
      * @see     java.util.Date
      */
-    public static native long currentTimeMillis();
+    public static long currentTimeMillis() {
+        return java.lang.System.currentTimeMillis();
+    }

     /**
      * Returns the current value of the running Java Virtual Machine's
@@ -393,7 +391,9 @@
      *         high-resolution time source, in nanoseconds
      * @since 1.5
      */
-    public static native long nanoTime();
+    public static long nanoTime() {
+        return java.lang.System.nanoTime();
+    }

     /**
      * Copies an array from the specified source array, beginning at the
@@ -487,9 +487,11 @@
      * @exception  NullPointerException if either <code>src</code> or
      *               <code>dest</code> is <code>null</code>.
      */
-    public static native void arraycopy(Object src,  int  srcPos,
+    public static void arraycopy(Object src,  int  srcPos,
                                         Object dest, int destPos,
-                                        int length);
+                                        int length) {
+        java.lang.System.arraycopy(src, srcPos, dest, destPos, length);
+    }

     /**
      * Returns the same hash code for the given object as
@@ -502,7 +504,9 @@
      * @return  the hashCode
      * @since   JDK1.1
      */
-    public static native int identityHashCode(Object x);
+    public static int identityHashCode(Object x) {
+        return java.lang.System.identityHashCode(x);
+    }

     /**
      * System properties. The following properties are guaranteed to be defined:
@@ -526,7 +530,10 @@
      */

     private static Properties props;
-    private static native Properties initProperties(Properties props);
+    private static Properties initProperties(Properties props) {
+        props.putAll(new AdaptedMap<>(java.lang.System.getProperties()));
+        return props;
+    }

     /**
      * Determines the current system properties.
@@ -615,7 +622,7 @@
      *              to the system properties.
      * @see        #setProperties
      * @see        java.lang.SecurityException
-     * @see        java.lang.SecurityManager#checkPropertiesAccess()
+     * @see        SecurityManager#checkPropertiesAccess()
      * @see        java.util.Properties
      */
     public static Properties getProperties() {
@@ -636,11 +643,9 @@
      * Windows systems it returns {@code "\r\n"}.
      */
     public static String lineSeparator() {
-        return lineSeparator;
+        return java.lang.System.lineSeparator();
     }

-    private static String lineSeparator;
-
     /**
      * Sets the system properties to the <code>Properties</code>
      * argument.
@@ -661,7 +666,7 @@
      * @see        #getProperties
      * @see        java.util.Properties
      * @see        java.lang.SecurityException
-     * @see        java.lang.SecurityManager#checkPropertiesAccess()
+     * @see        SecurityManager#checkPropertiesAccess()
      */
     public static void setProperties(Properties props) {
         SecurityManager sm = getSecurityManager();
@@ -698,8 +703,8 @@
      * @exception  IllegalArgumentException if <code>key</code> is empty.
      * @see        #setProperty
      * @see        java.lang.SecurityException
-     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)
-     * @see        java.lang.System#getProperties()
+     * @see        SecurityManager#checkPropertyAccess(java.lang.String)
+     * @see        System#getProperties()
      */
     public static String getProperty(String key) {
         checkKey(key);
@@ -734,8 +739,8 @@
      *             <code>null</code>.
      * @exception  IllegalArgumentException if <code>key</code> is empty.
      * @see        #setProperty
-     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)
-     * @see        java.lang.System#getProperties()
+     * @see        SecurityManager#checkPropertyAccess(java.lang.String)
+     * @see        System#getProperties()
      */
     public static String getProperty(String key, String def) {
         checkKey(key);
@@ -770,8 +775,8 @@
      *             <code>value</code> is <code>null</code>.
      * @exception  IllegalArgumentException if <code>key</code> is empty.
      * @see        #getProperty
-     * @see        java.lang.System#getProperty(java.lang.String)
-     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)
+     * @see        System#getProperty(java.lang.String)
+     * @see        System#getProperty(java.lang.String, java.lang.String)
      * @see        java.util.PropertyPermission
      * @see        SecurityManager#checkPermission
      * @since      1.2
@@ -811,7 +816,7 @@
      * @see        #setProperty
      * @see        java.util.Properties
      * @see        java.lang.SecurityException
-     * @see        java.lang.SecurityManager#checkPropertiesAccess()
+     * @see        SecurityManager#checkPropertiesAccess()
      * @since 1.5
      */
     public static String clearProperty(String key) {
@@ -885,7 +890,7 @@
             sm.checkPermission(new RuntimePermission("getenv."+name));
         }

-        return ProcessEnvironment.getenv(name);
+        return java.lang.System.getenv(name);
     }


@@ -929,13 +934,13 @@
      * @see    ProcessBuilder#environment()
      * @since  1.5
      */
-    public static java.util.Map<String,String> getenv() {
+    public static Map<String,String> getenv() {
         SecurityManager sm = getSecurityManager();
         if (sm != null) {
             sm.checkPermission(new RuntimePermission("getenv.*"));
         }

-        return ProcessEnvironment.getenv();
+        return new AdaptedMap<>(java.lang.System.getenv());
     }

     /**
@@ -1028,7 +1033,7 @@
      *
      * @see     java.lang.Runtime#exit(int)
      * @see     java.lang.Runtime#gc()
-     * @see     java.lang.SecurityManager#checkExit(int)
+     * @see     SecurityManager#checkExit(int)
      * @since   JDK1.1
      */
     @Deprecated
@@ -1055,11 +1060,10 @@
      * @exception  NullPointerException if <code>filename</code> is
      *             <code>null</code>
      * @see        java.lang.Runtime#load(java.lang.String)
-     * @see        java.lang.SecurityManager#checkLink(java.lang.String)
+     * @see        SecurityManager#checkLink(java.lang.String)
      */
-    @CallerSensitive
     public static void load(String filename) {
-        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);
+        java.lang.System.load(filename);
     }

     /**
@@ -1081,11 +1085,10 @@
      * @exception  NullPointerException if <code>libname</code> is
      *             <code>null</code>
      * @see        java.lang.Runtime#loadLibrary(java.lang.String)
-     * @see        java.lang.SecurityManager#checkLink(java.lang.String)
+     * @see        SecurityManager#checkLink(java.lang.String)
      */
-    @CallerSensitive
     public static void loadLibrary(String libname) {
-        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
+        java.lang.System.loadLibrary(libname);
     }

     /**
@@ -1096,122 +1099,142 @@
      * @return     a platform-dependent native library name.
      * @exception  NullPointerException if <code>libname</code> is
      *             <code>null</code>
-     * @see        java.lang.System#loadLibrary(java.lang.String)
+     * @see        System#loadLibrary(java.lang.String)
      * @see        java.lang.ClassLoader#findLibrary(java.lang.String)
      * @since      1.2
      */
-    public static native String mapLibraryName(String libname);
+    public static String mapLibraryName(String libname) {
+        return java.lang.System.mapLibraryName(libname);
+    }
+
+    private static final Unsafe UNSAFE;
+    private static final Object IN_BASE;
+    private static final long IN_OFFSET;
+    private static final Object OUT_BASE;
+    private static final long OUT_OFFSET;
+    private static final Object ERR_BASE;
+    private static final long ERR_OFFSET;

     /**
      * Initialize the system class.  Called after thread initialization.
      */
     private static void initializeSystemClass() {
-
-        // VM might invoke JNU_NewStringPlatform() to set those encoding
-        // sensitive properties (user.home, user.name, boot.class.path, etc.)
-        // during "props" initialization, in which it may need access, via
-        // System.getProperty(), to the related system encoding property that
-        // have been initialized (put into "props") at early stage of the
-        // initialization. So make sure the "props" is available at the
-        // very beginning of the initialization and all system properties to
-        // be put into it directly.
-        props = new Properties();
-        initProperties(props);  // initialized by the VM
-
-        // There are certain system configurations that may be controlled by
-        // VM options such as the maximum amount of direct memory and
-        // Integer cache size used to support the object identity semantics
-        // of autoboxing.  Typically, the library will obtain these values
-        // from the properties set by the VM.  If the properties are for
-        // internal implementation use only, these properties should be
-        // removed from the system properties.
-        //
-        // See java.lang.Integer.IntegerCache and the
-        // sun.misc.VM.saveAndRemoveProperties method for example.
-        //
-        // Save a private copy of the system properties object that
-        // can only be accessed by the internal implementation.  Remove
-        // certain system properties that are not intended for public access.
-        sun.misc.VM.saveAndRemoveProperties(props);
-
-
-        lineSeparator = props.getProperty("line.separator");
-        sun.misc.Version.init();
-
-        FileInputStream fdIn = new FileInputStream(FileDescriptor.in);
-        FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);
-        FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);
-        setIn0(new BufferedInputStream(fdIn));
-        setOut0(new PrintStream(new BufferedOutputStream(fdOut, 128), true));
-        setErr0(new PrintStream(new BufferedOutputStream(fdErr, 128), true));
-        // Load the zip library now in order to keep java.util.zip.ZipFile
-        // from trying to use itself to load this library later.
-        loadLibrary("zip");
-
-        // Setup Java signal handlers for HUP, TERM, and INT (where available).
-        Terminator.setup();
-
-        // Initialize any miscellenous operating system settings that need to be
-        // set for the class libraries. Currently this is no-op everywhere except
-        // for Windows where the process-wide error mode is set before the java.io
-        // classes are used.
-        sun.misc.VM.initializeOSEnvironment();
-
-        // The main thread is not added to its thread group in the same
-        // way as other threads; we must do it ourselves here.
-        Thread current = Thread.currentThread();
-        current.getThreadGroup().add(current);
-
-        // register shared secrets
-        setJavaLangAccess();
-
-        // Subsystems that are invoked during initialization can invoke
-        // sun.misc.VM.isBooted() in order to avoid doing things that should
-        // wait until the application class loader has been set up.
-        // IMPORTANT: Ensure that this remains the last initialization action!
-        sun.misc.VM.booted();
+        setIn0(java.lang.System.in);
+        setOut0(java.lang.System.out);
+        setErr0(java.lang.System.err);
     }

-    private static void setJavaLangAccess() {
-        // Allow privileged classes outside of java.lang
-        sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess(){
-            public sun.reflect.ConstantPool getConstantPool(Class klass) {
-                return klass.getConstantPool();
+    static {
+        Class<System> systemClass = System.class;
+        Field inField;
+        Field outField;
+        Field errField;
+
+        try {
+            inField = systemClass.getDeclaredField("in");
+            outField = systemClass.getDeclaredField("out");
+            errField = systemClass.getDeclaredField("err");
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+
+        UNSAFE = UnsafeHolder.getUnsafe();
+        IN_BASE = UNSAFE.staticFieldBase(inField);
+        IN_OFFSET = UNSAFE.staticFieldOffset(inField);
+        OUT_BASE = UNSAFE.staticFieldBase(outField);
+        OUT_OFFSET = UNSAFE.staticFieldOffset(outField);
+        ERR_BASE = UNSAFE.staticFieldBase(errField);
+        ERR_OFFSET = UNSAFE.staticFieldOffset(errField);
+
+        initializeSystemClass();
+    }
+
+    private static final class AdaptedMap<K, V> extends AbstractMap<K, V> implements Serializable {
+
+        private static final long serialVersionUID = 1L;
+
+        private final java.util.Map<K, V> map;
+
+        AdaptedMap(java.util.Map<K, V> map) {
+            this.map = map;
+        }
+
+        @Override
+        public Set<Entry<K, V>> entrySet() {
+            final java.util.Set<java.util.Map.Entry<K, V>> set = map.entrySet();
+            return new AbstractSet<Entry<K, V>>() {
+                @Override
+                public Iterator<Entry<K, V>> iterator() {
+                    final java.util.Iterator<java.util.Map.Entry<K, V>> iterator = set.iterator();
+                    return new Iterator<Entry<K, V>>() {
+                        @Override
+                        public boolean hasNext() {
+                            return iterator.hasNext();
+                        }
+
+                        @Override
+                        public Entry<K, V> next() {
+                            return new AdaptedEntry<>(iterator.next());
+                        }
+
+                        @Override
+                        public void remove() {
+                            iterator.remove();
+                        }
+                    };
+                }
+
+                @Override
+                public int size() {
+                    return set.size();
+                }
+            };
+        }
+
+        private static final class AdaptedEntry<K, V> implements Entry<K, V> {
+
+            private final java.util.Map.Entry<K, V> entry;
+
+            AdaptedEntry(java.util.Map.Entry<K, V> entry) {
+                this.entry = entry;
             }
-            public boolean casAnnotationType(Class<?> klass, AnnotationType oldType, AnnotationType newType) {
-                return klass.casAnnotationType(oldType, newType);
+
+            @Override
+            public K getKey() {
+                return entry.getKey();
             }
-            public AnnotationType getAnnotationType(Class klass) {
-                return klass.getAnnotationType();
+
+            @Override
+            public V getValue() {
+                return entry.getValue();
             }
-            public byte[] getRawClassAnnotations(Class<?> klass) {
-                return klass.getRawAnnotations();
+
+            @Override
+            public V setValue(V value) {
+                return entry.setValue(value);
             }
-            public <E extends Enum<E>>
-                    E[] getEnumConstantsShared(Class<E> klass) {
-                return klass.getEnumConstantsShared();
+
+            @Override
+            public boolean equals(Object o) {
+                if (o == this) {
+                    return true;
+                }
+                if (!(o instanceof AdaptedEntry)) {
+                    return false;
+                }
+                AdaptedEntry<?, ?> other = (AdaptedEntry<?, ?>) o;
+                return entry.equals(other.entry);
             }
-            public void blockedOn(Thread t, Interruptible b) {
-                t.blockedOn(b);
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
             }
-            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {
-                Shutdown.add(slot, registerShutdownInProgress, hook);
+
+            @Override
+            public String toString() {
+                return getKey() + "=" + getValue();
             }
-            public int getStackTraceDepth(Throwable t) {
-                return t.getStackTraceDepth();
-            }
-            public StackTraceElement getStackTraceElement(Throwable t, int i) {
-                return t.getStackTraceElement(i);
-            }
-            public int getStringHash32(String string) {
-                return string.hash32();
-            }
-            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {
-                return new Thread(target, acc);
-            }
-            public void invokeFinalize(Object o) throws Throwable {
-                o.finalize();
-            }
-        });
+        }
     }
 }
diff -r 55f6804b4352 src/share/classes/java/lang/Thread.java
--- a/src/share/classes/java/lang/Thread.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/lang/Thread.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,23 +23,29 @@
  * questions.
  */

-package java.lang;
+package org.jvnet.zephyr.jcl.java.lang;
+
+import org.jvnet.zephyr.jcl.impl.misc.ReflectionUtils;
+import org.jvnet.zephyr.jcl.impl.misc.SharedSecrets;
+import org.jvnet.zephyr.jcl.impl.nio.ch.Interruptible;
+import org.jvnet.zephyr.jcl.java.nio.channels.Selector;
+import org.jvnet.zephyr.jcl.java.util.HashMap;
+import org.jvnet.zephyr.jcl.java.util.Map;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport;
+import org.jvnet.zephyr.thread.JavaThreadImpl;
+import org.jvnet.zephyr.thread.ThreadAccess;
+import org.jvnet.zephyr.thread.ThreadImpl;
+import sun.security.util.SecurityConstants;

 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
+import java.security.AccessControlContext;
 import java.security.AccessController;
-import java.security.AccessControlContext;
 import java.security.PrivilegedAction;
-import java.util.Map;
-import java.util.HashMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.locks.LockSupport;
-import sun.nio.ch.Interruptible;
-import sun.reflect.CallerSensitive;
-import sun.reflect.Reflection;
-import sun.security.util.SecurityConstants;
+import java.util.concurrent.TimeUnit;


 /**
@@ -139,26 +144,27 @@
  */
 public
 class Thread implements Runnable {
-    /* Make sure registerNatives is the first thing <clinit> does. */
-    private static native void registerNatives();
-    static {
-        registerNatives();
-    }
+
+    private static final java.lang.ThreadLocal<Thread> currentThread = new java.lang.ThreadLocal<Thread>() {
+        @Override
+        protected Thread initialValue() {
+            return new Thread(java.lang.Thread.currentThread());
+        }
+    };
+    private static final ThreadAccess<Thread, Interruptible> threadAccess = new ThreadAccessImpl();
+
+    static {
+        SharedSecrets.setThreadAccess(threadAccess);
+    }
+
+    final ThreadImpl<Thread> impl;

     private char        name[];
     private int         priority;
-    private Thread      threadQ;
-    private long        eetop;
-
-    /* Whether or not to single_step this thread. */
-    private boolean     single_step;

     /* Whether or not the thread is a daemon thread. */
     private boolean     daemon = false;

-    /* JVM state */
-    private boolean     stillborn = false;
-
     /* What will be run. */
     private Runnable target;

@@ -195,11 +197,6 @@
     private long stackSize;

     /*
-     * JVM-private state that persists after native thread termination.
-     */
-    private long nativeParkEventPointer;
-
-    /*
      * Thread ID
      */
     private long tid;
@@ -207,22 +204,15 @@
     /* For generating thread ID */
     private static long threadSeqNumber;

-    /* Java thread status for tools,
-     * initialized to indicate thread 'not yet started'
-     */
-
-    private volatile int threadStatus = 0;
-
-
     private static synchronized long nextThreadID() {
         return ++threadSeqNumber;
     }

     /**
      * The argument supplied to the current call to
-     * java.util.concurrent.locks.LockSupport.park.
-     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
-     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
+     * org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport.park.
+     * Set by (private) org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport.setBlocker
+     * Accessed using org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport.getBlocker
      */
     volatile Object parkBlocker;

@@ -233,7 +223,7 @@
     private volatile Interruptible blocker;
     private final Object blockerLock = new Object();

-    /* Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code
+    /* Set the blocker field; invoked via sun.misc.SharedSecrets from org.jvnet.zephyr.jcl.java.nio code
      */
     void blockedOn(Interruptible b) {
         synchronized (blockerLock) {
@@ -261,7 +251,9 @@
      *
      * @return  the currently executing thread.
      */
-    public static native Thread currentThread();
+    public static Thread currentThread() {
+        return currentThread.get();
+    }

     /**
      * A hint to the scheduler that the current thread is willing to yield
@@ -277,9 +269,11 @@
      * for debugging or testing purposes, where it may help to reproduce
      * bugs due to race conditions. It may also be useful when designing
      * concurrency control constructs such as the ones in the
-     * {@link java.util.concurrent.locks} package.
+     * {@link org.jvnet.zephyr.jcl.java.util.concurrent.locks} package.
      */
-    public static native void yield();
+    public static void yield() {
+        currentThread().impl.yield();
+    }

     /**
      * Causes the currently executing thread to sleep (temporarily cease
@@ -298,7 +292,9 @@
      *          <i>interrupted status</i> of the current thread is
      *          cleared when this exception is thrown.
      */
-    public static native void sleep(long millis) throws InterruptedException;
+    public static void sleep(long millis) throws InterruptedException {
+        currentThread().impl.sleep(millis, TimeUnit.MILLISECONDS);
+    }

     /**
      * Causes the currently executing thread to sleep (temporarily cease
@@ -442,6 +438,7 @@
      * {@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
      */
     public Thread() {
+        impl = ThreadImpl.create(this, threadAccess);
         init(null, null, "Thread-" + nextThreadNum(), 0);
     }

@@ -458,6 +455,7 @@
      *         nothing.
      */
     public Thread(Runnable target) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(null, target, "Thread-" + nextThreadNum(), 0);
     }

@@ -466,6 +464,7 @@
      * This is not a public constructor.
      */
     Thread(Runnable target, AccessControlContext acc) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(null, target, "Thread-" + nextThreadNum(), 0, acc);
     }

@@ -493,6 +492,7 @@
      *          thread group
      */
     public Thread(ThreadGroup group, Runnable target) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(group, target, "Thread-" + nextThreadNum(), 0);
     }

@@ -505,6 +505,7 @@
      *          the name of the new thread
      */
     public Thread(String name) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(null, null, name, 0);
     }

@@ -529,6 +530,7 @@
      *          thread group
      */
     public Thread(ThreadGroup group, String name) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(group, null, name, 0);
     }

@@ -545,6 +547,7 @@
      *         the name of the new thread
      */
     public Thread(Runnable target, String name) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(null, target, name, 0);
     }

@@ -593,6 +596,7 @@
      *          thread group or cannot override the context class loader methods.
      */
     public Thread(ThreadGroup group, Runnable target, String name) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(group, target, name, 0);
     }

@@ -672,9 +676,21 @@
      */
     public Thread(ThreadGroup group, Runnable target, String name,
                   long stackSize) {
+        impl = ThreadImpl.create(this, threadAccess);
         init(group, target, name, stackSize);
     }

+    Thread(java.lang.Thread javaThread) {
+        impl = new JavaThreadImpl(javaThread);
+        name = javaThread.getName().toCharArray();
+        group = new ThreadGroup(ThreadGroup.ROOT, javaThread.getThreadGroup().getName());
+        daemon = javaThread.isDaemon();
+        priority = javaThread.getPriority();
+        contextClassLoader = javaThread.getContextClassLoader();
+        inheritedAccessControlContext = AccessController.getContext();
+        tid = nextThreadID();
+    }
+
     /**
      * Causes this thread to begin execution; the Java Virtual Machine
      * calls the <code>run</code> method of this thread.
@@ -701,7 +717,7 @@
          *
          * A zero status value corresponds to state "NEW".
          */
-        if (threadStatus != 0)
+        if (getState() != State.NEW)
             throw new IllegalThreadStateException();

         /* Notify the group that this thread is about to be started
@@ -725,7 +741,9 @@
         }
     }

-    private native void start0();
+    private void start0() {
+        impl.start();
+    }

     /**
      * If this thread was constructed using a separate
@@ -900,7 +918,7 @@
         }
         // A zero status value corresponds to "NEW", it can't change to
         // not-NEW because we hold the lock.
-        if (threadStatus != 0) {
+        if (getState() != State.NEW) {
             resume(); // Wake up thread if it was suspended; no-op otherwise
         }

@@ -930,11 +948,11 @@
      * status will be set, and the thread will receive a {@link
      * java.nio.channels.ClosedByInterruptException}.
      *
-     * <p> If this thread is blocked in a {@link java.nio.channels.Selector}
+     * <p> If this thread is blocked in a {@link Selector}
      * then the thread's interrupt status will be set and it will return
      * immediately from the selection operation, possibly with a non-zero
      * value, just as if the selector's {@link
-     * java.nio.channels.Selector#wakeup wakeup} method were invoked.
+     * Selector#wakeup wakeup} method were invoked.
      *
      * <p> If none of the previous conditions hold then this thread's interrupt
      * status will be set. </p>
@@ -980,7 +998,7 @@
      * @revised 6.0
      */
     public static boolean interrupted() {
-        return currentThread().isInterrupted(true);
+        return currentThread().impl.interrupted();
     }

     /**
@@ -997,17 +1015,10 @@
      * @revised 6.0
      */
     public boolean isInterrupted() {
-        return isInterrupted(false);
+        return impl.isInterrupted();
     }

     /**
-     * Tests if some Thread has been interrupted.  The interrupted state
-     * is reset or not based on the value of ClearInterrupted that is
-     * passed.
-     */
-    private native boolean isInterrupted(boolean ClearInterrupted);
-
-    /**
      * Throws {@link NoSuchMethodError}.
      *
      * @deprecated This method was originally designed to destroy this
@@ -1036,7 +1047,9 @@
      * @return  <code>true</code> if this thread is alive;
      *          <code>false</code> otherwise.
      */
-    public final native boolean isAlive();
+    public final boolean isAlive() {
+        return impl.isAlive();
+    }

     /**
      * Suspends this thread.
@@ -1128,7 +1141,7 @@
             if (newPriority > g.getMaxPriority()) {
                 newPriority = g.getMaxPriority();
             }
-            setPriority0(priority = newPriority);
+            priority = newPriority;
         }
     }

@@ -1184,7 +1197,7 @@

     /**
      * Returns an estimate of the number of active threads in the current
-     * thread's {@linkplain java.lang.ThreadGroup thread group} and its
+     * thread's {@linkplain ThreadGroup thread group} and its
      * subgroups. Recursively iterates over all subgroups in the current
      * thread's thread group.
      *
@@ -1205,7 +1218,7 @@
     /**
      * Copies into the specified array every active thread in the current
      * thread's thread group and its subgroups. This method simply
-     * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
+     * invokes the {@link ThreadGroup#enumerate(Thread[])}
      * method of the current thread's thread group.
      *
      * <p> An application might use the {@linkplain #activeCount activeCount}
@@ -1225,7 +1238,7 @@
      * @return  the number of threads put into the array
      *
      * @throws  SecurityException
-     *          if {@link java.lang.ThreadGroup#checkAccess} determines that
+     *          if {@link ThreadGroup#checkAccess} determines that
      *          the current thread cannot access its thread group
      */
     public static int enumerate(Thread tarray[]) {
@@ -1244,7 +1257,9 @@
      *             were never well-defined.
      */
     @Deprecated
-    public native int countStackFrames();
+    public int countStackFrames() {
+        throw new UnsupportedOperationException();
+    }

     /**
      * Waits at most {@code millis} milliseconds for this thread to
@@ -1267,29 +1282,9 @@
      *          <i>interrupted status</i> of the current thread is
      *          cleared when this exception is thrown.
      */
-    public final synchronized void join(long millis)
+    public final void join(long millis)
     throws InterruptedException {
-        long base = System.currentTimeMillis();
-        long now = 0;
-
-        if (millis < 0) {
-            throw new IllegalArgumentException("timeout value is negative");
-        }
-
-        if (millis == 0) {
-            while (isAlive()) {
-                wait(0);
-            }
-        } else {
-            while (isAlive()) {
-                long delay = millis - now;
-                if (delay <= 0) {
-                    break;
-                }
-                wait(delay);
-                now = System.currentTimeMillis() - base;
-            }
-        }
+        impl.join(millis, TimeUnit.MILLISECONDS);
     }

     /**
@@ -1317,7 +1312,7 @@
      *          <i>interrupted status</i> of the current thread is
      *          cleared when this exception is thrown.
      */
-    public final synchronized void join(long millis, int nanos)
+    public final void join(long millis, int nanos)
     throws InterruptedException {

         if (millis < 0) {
@@ -1352,7 +1347,7 @@
      *          cleared when this exception is thrown.
      */
     public final void join() throws InterruptedException {
-        join(0);
+        impl.join();
     }

     /**
@@ -1463,19 +1458,55 @@
      *
      * @since 1.2
      */
-    @CallerSensitive
     public ClassLoader getContextClassLoader() {
         if (contextClassLoader == null)
             return null;

         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
-            ClassLoader.checkClassLoaderPermission(contextClassLoader,
-                                                   Reflection.getCallerClass());
+            checkClassLoaderPermission(contextClassLoader, ReflectionUtils.getClassContext()[3]);
         }
         return contextClassLoader;
     }

+    private static void checkClassLoaderPermission(ClassLoader cl, Class<?> caller) {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            ClassLoader ccl = getClassLoader(caller);
+            if (needsClassLoaderPermissionCheck(ccl, cl)) {
+                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
+            }
+        }
+    }
+
+    private static ClassLoader getClassLoader(Class<?> caller) {
+        if (caller == null) {
+            return null;
+        }
+        return caller.getClassLoader();
+    }
+
+    private static boolean needsClassLoaderPermissionCheck(ClassLoader from, ClassLoader to) {
+        if (from == to) {
+            return false;
+        }
+        if (from == null) {
+            return false;
+        }
+        return !isAncestor(from, to);
+    }
+
+    private static boolean isAncestor(ClassLoader from, ClassLoader to) {
+        ClassLoader acl = to;
+        do {
+            acl = acl.getParent();
+            if (from == acl) {
+                return true;
+            }
+        } while (acl != null);
+        return false;
+    }
+
     /**
      * Sets the context ClassLoader for this Thread. The context
      * ClassLoader can be set when a thread is created, and allows
@@ -1522,7 +1553,9 @@
      *         the specified object.
      * @since 1.4
      */
-    public static native boolean holdsLock(Object obj);
+    public static boolean holdsLock(Object obj) {
+        return java.lang.Thread.holdsLock(obj);
+    }

     private static final StackTraceElement[] EMPTY_STACK_TRACE
         = new StackTraceElement[0];
@@ -1719,8 +1752,13 @@
         return result.booleanValue();
     }

-    private native static StackTraceElement[][] dumpThreads(Thread[] threads);
-    private native static Thread[] getThreads();
+    private static StackTraceElement[][] dumpThreads(Thread[] threads) {
+        return new StackTraceElement[threads.length][];
+    }
+
+    private static Thread[] getThreads() {
+        return new Thread[] { Thread.currentThread() };
+    }

     /**
      * Returns the identifier of this Thread.  The thread ID is a positive
@@ -1844,7 +1882,20 @@
      */
     public State getState() {
         // get current thread state
-        return sun.misc.VM.toThreadState(threadStatus);
+        switch (impl.getState()) {
+            case ThreadImpl.NEW:
+                return State.NEW;
+            case ThreadImpl.RUNNABLE:
+                return State.RUNNABLE;
+            case ThreadImpl.WAITING:
+                return State.WAITING;
+            case ThreadImpl.TIMED_WAITING:
+                return State.TIMED_WAITING;
+            case ThreadImpl.TERMINATED:
+                return State.TERMINATED;
+            default:
+                throw new AssertionError();
+        }
     }

     // Added in JSR-166
@@ -2049,10 +2100,50 @@
     }

     /* Some private helper methods */
-    private native void setPriority0(int newPriority);
-    private native void stop0(Object o);
-    private native void suspend0();
-    private native void resume0();
-    private native void interrupt0();
-    private native void setNativeName(String name);
+    private void stop0(Object o) {
+        throw new UnsupportedOperationException();
+    }
+
+    private void suspend0() {
+        throw new UnsupportedOperationException();
+    }
+
+    private void resume0() {
+        throw new UnsupportedOperationException();
+    }
+
+    private void interrupt0() {
+        impl.interrupt();
+    }
+
+    private static final class ThreadAccessImpl implements ThreadAccess<Thread, Interruptible> {
+
+        ThreadAccessImpl() {
+        }
+
+        @Override
+        public Thread currentThread() {
+            return Thread.currentThread();
+        }
+
+        @Override
+        public void setCurrentThread(Thread thread) {
+            currentThread.set(thread);
+        }
+
+        @Override
+        public ThreadImpl<Thread> getImpl(Thread thread) {
+            return thread.impl;
+        }
+
+        @Override
+        public void dispatchUncaughtException(Thread thread, Throwable e) {
+            thread.dispatchUncaughtException(e);
+        }
+
+        @Override
+        public void blockedOn(Thread thread, Interruptible interruptible) {
+            thread.blockedOn(interruptible);
+        }
+    }
 }
diff -r 55f6804b4352 src/share/classes/java/lang/ThreadGroup.java
--- a/src/share/classes/java/lang/ThreadGroup.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/lang/ThreadGroup.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,11 +23,12 @@
  * questions.
  */

-package java.lang;
+package org.jvnet.zephyr.jcl.java.lang;
+
+import sun.misc.VM;

 import java.io.PrintStream;
 import java.util.Arrays;
-import sun.misc.VM;

 /**
  * A thread group represents a set of threads. In addition, a thread
@@ -55,6 +56,9 @@
  */
 public
 class ThreadGroup implements Thread.UncaughtExceptionHandler {
+
+    static ThreadGroup ROOT = new ThreadGroup();
+
     private final ThreadGroup parent;
     String name;
     int maxPriority;
@@ -89,7 +93,7 @@
      * @param   name   the name of the new thread group.
      * @exception  SecurityException  if the current thread cannot create a
      *               thread in the specified thread group.
-     * @see     java.lang.ThreadGroup#checkAccess()
+     * @see     ThreadGroup#checkAccess()
      * @since   JDK1.0
      */
     public ThreadGroup(String name) {
@@ -110,7 +114,7 @@
      * @exception  SecurityException  if the current thread cannot create a
      *               thread in the specified thread group.
      * @see     java.lang.SecurityException
-     * @see     java.lang.ThreadGroup#checkAccess()
+     * @see     ThreadGroup#checkAccess()
      * @since   JDK1.0
      */
     public ThreadGroup(ThreadGroup parent, String name) {
@@ -157,7 +161,7 @@
      *          is the only thread group whose parent is <code>null</code>.
      * @exception  SecurityException  if the current thread cannot modify
      *               this thread group.
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        ThreadGroup#checkAccess()
      * @see        java.lang.SecurityException
      * @see        java.lang.RuntimePermission
      * @since   JDK1.0
@@ -220,7 +224,7 @@
      * @exception  SecurityException  if the current thread cannot modify
      *               this thread group.
      * @see        java.lang.SecurityException
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        ThreadGroup#checkAccess()
      * @since      JDK1.0
      */
     public final void setDaemon(boolean daemon) {
@@ -253,7 +257,7 @@
      *               this thread group.
      * @see        #getMaxPriority
      * @see        java.lang.SecurityException
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        ThreadGroup#checkAccess()
      * @since      JDK1.0
      */
     public final void setMaxPriority(int pri) {
@@ -306,7 +310,7 @@
      *
      * @exception  SecurityException  if the current thread is not allowed to
      *               access this thread group.
-     * @see        java.lang.SecurityManager#checkAccess(java.lang.ThreadGroup)
+     * @see        SecurityManager#checkAccess(ThreadGroup)
      * @since      JDK1.0
      */
     public final void checkAccess() {
@@ -601,8 +605,8 @@
      *               to access this thread group or any of the threads in
      *               the thread group.
      * @see        java.lang.SecurityException
-     * @see        java.lang.Thread#stop()
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        Thread#stop()
+     * @see        ThreadGroup#checkAccess()
      * @since      JDK1.0
      * @deprecated    This method is inherently unsafe.  See
      *     {@link Thread#stop} for details.
@@ -625,9 +629,9 @@
      * @exception  SecurityException  if the current thread is not allowed
      *               to access this thread group or any of the threads in
      *               the thread group.
-     * @see        java.lang.Thread#interrupt()
+     * @see        Thread#interrupt()
      * @see        java.lang.SecurityException
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        ThreadGroup#checkAccess()
      * @since      1.2
      */
     public final void interrupt() {
@@ -662,9 +666,9 @@
      * @exception  SecurityException  if the current thread is not allowed
      *               to access this thread group or any of the threads in
      *               the thread group.
-     * @see        java.lang.Thread#suspend()
+     * @see        Thread#suspend()
      * @see        java.lang.SecurityException
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        ThreadGroup#checkAccess()
      * @since      JDK1.0
      * @deprecated    This method is inherently deadlock-prone.  See
      *     {@link Thread#suspend} for details.
@@ -722,8 +726,8 @@
      *               access this thread group or any of the threads in the
      *               thread group.
      * @see        java.lang.SecurityException
-     * @see        java.lang.Thread#resume()
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        Thread#resume()
+     * @see        ThreadGroup#checkAccess()
      * @since      JDK1.0
      * @deprecated    This method is used solely in conjunction with
      *      <tt>Thread.suspend</tt> and <tt>ThreadGroup.suspend</tt>,
@@ -763,7 +767,7 @@
      *               empty or if the thread group has already been destroyed.
      * @exception  SecurityException  if the current thread cannot modify this
      *               thread group.
-     * @see        java.lang.ThreadGroup#checkAccess()
+     * @see        ThreadGroup#checkAccess()
      * @since      JDK1.0
      */
     public final void destroy() {
diff -r 55f6804b4352 src/share/classes/java/lang/ThreadLocal.java
--- a/src/share/classes/java/lang/ThreadLocal.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/lang/ThreadLocal.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,9 +23,11 @@
  * questions.
  */

-package java.lang;
-import java.lang.ref.*;
-import java.util.concurrent.atomic.AtomicInteger;
+package org.jvnet.zephyr.jcl.java.lang;
+
+import org.jvnet.zephyr.jcl.java.util.concurrent.atomic.AtomicInteger;
+
+import java.lang.ref.WeakReference;

 /**
  * This class provides thread-local variables.  These variables differ from
diff -r 55f6804b4352 src/share/classes/java/nio/channels/DatagramChannel.java
--- a/src/share/classes/java/nio/channels/DatagramChannel.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/DatagramChannel.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,16 +23,30 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;
+
+import org.jvnet.zephyr.jcl.java.lang.SecurityManager;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.AbstractSelectableChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;

 import java.io.IOException;
+import java.net.DatagramSocket;
 import java.net.ProtocolFamily;
-import java.net.DatagramSocket;
+import java.net.SocketAddress;
 import java.net.SocketOption;
-import java.net.SocketAddress;
 import java.nio.ByteBuffer;
-import java.nio.channels.spi.AbstractSelectableChannel;
-import java.nio.channels.spi.SelectorProvider;
+import java.nio.channels.AlreadyBoundException;
+import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.ByteChannel;
+import java.nio.channels.ClosedByInterruptException;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.MulticastChannel;
+import java.nio.channels.NotYetConnectedException;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+import java.nio.channels.UnsupportedAddressTypeException;
+import java.nio.channels.WritableByteChannel;

 /**
  * A selectable channel for datagram-oriented sockets.
@@ -126,9 +140,9 @@
      * Opens a datagram channel.
      *
      * <p> The new channel is created by invoking the {@link
-     * java.nio.channels.spi.SelectorProvider#openDatagramChannel()
+     * SelectorProvider#openDatagramChannel()
      * openDatagramChannel} method of the system-wide default {@link
-     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be
+     * SelectorProvider} object.  The channel will not be
      * connected.
      *
      * <p> The {@link ProtocolFamily ProtocolFamily} of the channel's socket
@@ -155,9 +169,9 @@
      * that this channel will join.
      *
      * <p> The new channel is created by invoking the {@link
-     * java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)
+     * SelectorProvider#openDatagramChannel(ProtocolFamily)
      * openDatagramChannel} method of the system-wide default {@link
-     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be
+     * SelectorProvider} object.  The channel will not be
      * connected.
      *
      * @param   family
@@ -254,8 +268,8 @@
      * java.net.DatagramSocket#connect connect} method of the {@link
      * java.net.DatagramSocket} class.  That is, if a security manager has been
      * installed then this method verifies that its {@link
-     * java.lang.SecurityManager#checkAccept checkAccept} and {@link
-     * java.lang.SecurityManager#checkConnect checkConnect} methods permit
+     * SecurityManager#checkAccept checkAccept} and {@link
+     * SecurityManager#checkConnect checkConnect} methods permit
      * datagrams to be received from and sent to, respectively, the given
      * remote address.
      *
@@ -352,7 +366,7 @@
      * to a specific remote address and a security manager has been installed
      * then for each datagram received this method verifies that the source's
      * address and port number are permitted by the security manager's {@link
-     * java.lang.SecurityManager#checkAccept checkAccept} method.  The overhead
+     * SecurityManager#checkAccept checkAccept} method.  The overhead
      * of this security check can be avoided by first connecting the socket via
      * the {@link #connect connect} method.
      *
@@ -412,7 +426,7 @@
      * to a specific remote address and a security manager has been installed
      * then for each datagram sent this method verifies that the target address
      * and port number are permitted by the security manager's {@link
-     * java.lang.SecurityManager#checkConnect checkConnect} method.  The
+     * SecurityManager#checkConnect checkConnect} method.  The
      * overhead of this security check can be avoided by first connecting the
      * socket via the {@link #connect connect} method.
      *
diff -r 55f6804b4352 src/share/classes/java/nio/channels/Pipe.java
--- a/src/share/classes/java/nio/channels/Pipe.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/Pipe.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,11 +23,16 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;
+
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.AbstractSelectableChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;

 import java.io.IOException;
-import java.nio.channels.spi.*;
-
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+import java.nio.channels.WritableByteChannel;

 /**
  * A pair of channels that implements a unidirectional pipe.
@@ -137,8 +142,8 @@
      * Opens a pipe.
      *
      * <p> The new pipe is created by invoking the {@link
-     * java.nio.channels.spi.SelectorProvider#openPipe openPipe} method of the
-     * system-wide default {@link java.nio.channels.spi.SelectorProvider}
+     * SelectorProvider#openPipe openPipe} method of the
+     * system-wide default {@link SelectorProvider}
      * object.  </p>
      *
      * @return  A new pipe
diff -r 55f6804b4352 src/share/classes/java/nio/channels/SelectableChannel.java
--- a/src/share/classes/java/nio/channels/SelectableChannel.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/SelectableChannel.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,12 +23,18 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;
+
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.AbstractInterruptibleChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;

 import java.io.IOException;
-import java.nio.channels.spi.AbstractInterruptibleChannel;
-import java.nio.channels.spi.SelectorProvider;
-
+import java.nio.channels.CancelledKeyException;
+import java.nio.channels.Channel;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.ClosedSelectorException;
+import java.nio.channels.IllegalBlockingModeException;
+import java.nio.channels.IllegalSelectorException;

 /**
  * A channel that can be multiplexed via a {@link Selector}.
@@ -237,7 +243,7 @@
      * behaves in exactly the same way as the invocation
      *
      * <blockquote><tt>sc.{@link
-     * #register(java.nio.channels.Selector,int,java.lang.Object)
+     * #register(Selector,int,java.lang.Object)
      * register}(sel, ops, null)</tt></blockquote>
      *
      * @param  sel
diff -r 55f6804b4352 src/share/classes/java/nio/channels/SelectionKey.java
--- a/src/share/classes/java/nio/channels/SelectionKey.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/SelectionKey.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,11 +23,11 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;

-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import java.io.IOException;
+import org.jvnet.zephyr.jcl.java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

+import java.nio.channels.CancelledKeyException;

 /**
  * A token representing the registration of a {@link SelectableChannel} with a
diff -r 55f6804b4352 src/share/classes/java/nio/channels/Selector.java
--- a/src/share/classes/java/nio/channels/Selector.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/Selector.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,12 +23,16 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Set;

 import java.io.Closeable;
 import java.io.IOException;
-import java.nio.channels.spi.SelectorProvider;
-import java.util.Set;
+import java.nio.channels.ClosedSelectorException;


 /**
@@ -36,9 +40,9 @@
  *
  * <p> A selector may be created by invoking the {@link #open open} method of
  * this class, which will use the system's default {@link
- * java.nio.channels.spi.SelectorProvider </code>selector provider<code>} to
+ * SelectorProvider </code>selector provider<code>} to
  * create a new selector.  A selector may also be created by invoking the
- * {@link java.nio.channels.spi.SelectorProvider#openSelector openSelector}
+ * {@link SelectorProvider#openSelector openSelector}
  * method of a custom selector provider.  A selector remains open until it is
  * closed via its {@link #close close} method.
  *
@@ -82,9 +86,9 @@
  *
  * <a name="sks"><p> Keys are added to the selected-key set by selection
  * operations.  A key may be removed directly from the selected-key set by
- * invoking the set's {@link java.util.Set#remove(java.lang.Object) remove}
- * method or by invoking the {@link java.util.Iterator#remove() remove} method
- * of an {@link java.util.Iterator </code>iterator<code>} obtained from the
+ * invoking the set's {@link Set#remove(java.lang.Object) remove}
+ * method or by invoking the {@link Iterator#remove() remove} method
+ * of an {@link Iterator </code>iterator<code>} obtained from the
  * set.  Keys are never removed from the selected-key set in any other way;
  * they are not, in particular, removed as a side effect of selection
  * operations.  Keys may not be added directly to the selected-key set. </p>
@@ -174,7 +178,7 @@
  *   </p></li>
  *
  *   <li><p> By invoking the blocked thread's {@link
- *   java.lang.Thread#interrupt() interrupt} method, in which case its
+ *   Thread#interrupt() interrupt} method, in which case its
  *   interrupt status will be set and the selector's {@link #wakeup wakeup}
  *   method will be invoked. </p></li>
  *
@@ -189,9 +193,9 @@
  * by multiple concurrent threads.  If such a thread might modify one of these
  * sets directly then access should be controlled by synchronizing on the set
  * itself.  The iterators returned by these sets' {@link
- * java.util.Set#iterator() iterator} methods are <i>fail-fast:</i> If the set
+ * Set#iterator() iterator} methods are <i>fail-fast:</i> If the set
  * is modified after the iterator is created, in any way except by invoking the
- * iterator's own {@link java.util.Iterator#remove() remove} method, then a
+ * iterator's own {@link Iterator#remove() remove} method, then a
  * {@link java.util.ConcurrentModificationException} will be thrown. </p>
  *
  *
@@ -214,9 +218,9 @@
      * Opens a selector.
      *
      * <p> The new selector is created by invoking the {@link
-     * java.nio.channels.spi.SelectorProvider#openSelector openSelector} method
+     * SelectorProvider#openSelector openSelector} method
      * of the system-wide default {@link
-     * java.nio.channels.spi.SelectorProvider} object.  </p>
+     * SelectorProvider} object.  </p>
      *
      * @return  A new selector
      *
diff -r 55f6804b4352 src/share/classes/java/nio/channels/ServerSocketChannel.java
--- a/src/share/classes/java/nio/channels/ServerSocketChannel.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/ServerSocketChannel.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,14 +23,23 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;
+
+import org.jvnet.zephyr.jcl.java.lang.SecurityManager;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.AbstractSelectableChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;

 import java.io.IOException;
 import java.net.ServerSocket;
+import java.net.SocketAddress;
 import java.net.SocketOption;
-import java.net.SocketAddress;
-import java.nio.channels.spi.AbstractSelectableChannel;
-import java.nio.channels.spi.SelectorProvider;
+import java.nio.channels.AlreadyBoundException;
+import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.ClosedByInterruptException;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.NetworkChannel;
+import java.nio.channels.NotYetBoundException;
+import java.nio.channels.UnsupportedAddressTypeException;

 /**
  * A selectable channel for stream-oriented listening sockets.
@@ -87,9 +96,9 @@
      * Opens a server-socket channel.
      *
      * <p> The new channel is created by invoking the {@link
-     * java.nio.channels.spi.SelectorProvider#openServerSocketChannel
+     * SelectorProvider#openServerSocketChannel
      * openServerSocketChannel} method of the system-wide default {@link
-     * java.nio.channels.spi.SelectorProvider} object.
+     * SelectorProvider} object.
      *
      * <p> The new channel's socket is initially unbound; it must be bound to a
      * specific address via one of its socket's {@link
@@ -233,7 +242,7 @@
      * installed then for each new connection this method verifies that the
      * address and port number of the connection's remote endpoint are
      * permitted by the security manager's {@link
-     * java.lang.SecurityManager#checkAccept checkAccept} method.  </p>
+     * SecurityManager#checkAccept checkAccept} method.  </p>
      *
      * @return  The socket channel for the new connection,
      *          or <tt>null</tt> if this channel is in non-blocking mode
diff -r 55f6804b4352 src/share/classes/java/nio/channels/SocketChannel.java
--- a/src/share/classes/java/nio/channels/SocketChannel.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/SocketChannel.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,15 +23,32 @@
  * questions.
  */

-package java.nio.channels;
+package org.jvnet.zephyr.jcl.java.nio.channels;
+
+import org.jvnet.zephyr.jcl.java.lang.SecurityManager;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.AbstractSelectableChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider;

 import java.io.IOException;
 import java.net.Socket;
+import java.net.SocketAddress;
 import java.net.SocketOption;
-import java.net.SocketAddress;
 import java.nio.ByteBuffer;
-import java.nio.channels.spi.AbstractSelectableChannel;
-import java.nio.channels.spi.SelectorProvider;
+import java.nio.channels.AlreadyBoundException;
+import java.nio.channels.AlreadyConnectedException;
+import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.ByteChannel;
+import java.nio.channels.Channel;
+import java.nio.channels.ClosedByInterruptException;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.ConnectionPendingException;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.NetworkChannel;
+import java.nio.channels.NoConnectionPendingException;
+import java.nio.channels.NotYetConnectedException;
+import java.nio.channels.ScatteringByteChannel;
+import java.nio.channels.UnresolvedAddressException;
+import java.nio.channels.UnsupportedAddressTypeException;

 /**
  * A selectable channel for stream-oriented connecting sockets.
@@ -129,9 +146,9 @@
      * Opens a socket channel.
      *
      * <p> The new channel is created by invoking the {@link
-     * java.nio.channels.spi.SelectorProvider#openSocketChannel
+     * SelectorProvider#openSocketChannel
      * openSocketChannel} method of the system-wide default {@link
-     * java.nio.channels.spi.SelectorProvider} object.  </p>
+     * SelectorProvider} object.  </p>
      *
      * @return  A new socket channel
      *
@@ -327,7 +344,7 @@
      * <p> This method performs exactly the same security checks as the {@link
      * java.net.Socket} class.  That is, if a security manager has been
      * installed then this method verifies that its {@link
-     * java.lang.SecurityManager#checkConnect checkConnect} method permits
+     * SecurityManager#checkConnect checkConnect} method permits
      * connecting to the address and port number of the given remote endpoint.
      *
      * <p> This method may be invoked at any time.  If a read or write
diff -r 55f6804b4352 src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
--- a/src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java	Fri Jul 31 15:48:18 2015 +0300
@@ -26,15 +26,17 @@
 /*
  */

-package java.nio.channels.spi;
+package org.jvnet.zephyr.jcl.java.nio.channels.spi;
+
+import org.jvnet.zephyr.jcl.impl.misc.SharedSecrets;
+import org.jvnet.zephyr.jcl.impl.nio.ch.Interruptible;
+import org.jvnet.zephyr.jcl.java.lang.Thread;

 import java.io.IOException;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-import java.nio.channels.*;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import sun.nio.ch.Interruptible;
+import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.Channel;
+import java.nio.channels.ClosedByInterruptException;
+import java.nio.channels.InterruptibleChannel;


 /**
@@ -208,7 +210,7 @@

     // -- sun.misc.SharedSecrets --
     static void blockedOn(Interruptible intr) {         // package-private
-        sun.misc.SharedSecrets.getJavaLangAccess().blockedOn(Thread.currentThread(),
+        SharedSecrets.getThreadAccess().blockedOn(Thread.currentThread(),
                                                              intr);
     }
 }
diff -r 55f6804b4352 src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java
--- a/src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,10 +23,19 @@
  * questions.
  */

-package java.nio.channels.spi;
+package org.jvnet.zephyr.jcl.java.nio.channels.spi;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.nio.channels.SelectableChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.SelectionKey;
+import org.jvnet.zephyr.jcl.java.nio.channels.Selector;

 import java.io.IOException;
-import java.nio.channels.*;
+import java.nio.channels.CancelledKeyException;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.ClosedSelectorException;
+import java.nio.channels.IllegalBlockingModeException;
+import java.nio.channels.IllegalSelectorException;


 /**
@@ -36,7 +45,7 @@
  * registration, deregistration, and closing.  It maintains the current
  * blocking mode of this channel as well as its current set of selection keys.
  * It performs all of the synchronization required to implement the {@link
- * java.nio.channels.SelectableChannel} specification.  Implementations of the
+ * SelectableChannel} specification.  Implementations of the
  * abstract protected methods defined in this class need not synchronize
  * against other threads that might be engaged in the same operations.  </p>
  *
diff -r 55f6804b4352 src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java
--- a/src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/spi/AbstractSelectionKey.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,9 +23,9 @@
  * questions.
  */

-package java.nio.channels.spi;
+package org.jvnet.zephyr.jcl.java.nio.channels.spi;

-import java.nio.channels.*;
+import org.jvnet.zephyr.jcl.java.nio.channels.SelectionKey;


 /**
diff -r 55f6804b4352 src/share/classes/java/nio/channels/spi/AbstractSelector.java
--- a/src/share/classes/java/nio/channels/spi/AbstractSelector.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/spi/AbstractSelector.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,14 +23,16 @@
  * questions.
  */

-package java.nio.channels.spi;
+package org.jvnet.zephyr.jcl.java.nio.channels.spi;
+
+import org.jvnet.zephyr.jcl.impl.nio.ch.Interruptible;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.nio.channels.SelectionKey;
+import org.jvnet.zephyr.jcl.java.nio.channels.Selector;
+import org.jvnet.zephyr.jcl.java.util.HashSet;
+import org.jvnet.zephyr.jcl.java.util.Set;

 import java.io.IOException;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.util.HashSet;
-import java.util.Set;
-import sun.nio.ch.Interruptible;
 import java.util.concurrent.atomic.AtomicBoolean;


@@ -119,7 +121,7 @@
      * <p> An implementation of this method must arrange for any other thread
      * that is blocked in a selection operation upon this selector to return
      * immediately as if by invoking the {@link
-     * java.nio.channels.Selector#wakeup wakeup} method. </p>
+     * Selector#wakeup wakeup} method. </p>
      *
      * @throws  IOException
      *          If an I/O error occurs while closing the selector
diff -r 55f6804b4352 src/share/classes/java/nio/channels/spi/SelectorProvider.java
--- a/src/share/classes/java/nio/channels/spi/SelectorProvider.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/nio/channels/spi/SelectorProvider.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,17 +23,25 @@
  * questions.
  */

-package java.nio.channels.spi;
+package org.jvnet.zephyr.jcl.java.nio.channels.spi;
+
+import org.jvnet.zephyr.jcl.impl.nio.ch.DefaultSelectorProvider;
+import org.jvnet.zephyr.jcl.java.lang.SecurityManager;
+import org.jvnet.zephyr.jcl.java.lang.System;
+import org.jvnet.zephyr.jcl.java.nio.channels.DatagramChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.Pipe;
+import org.jvnet.zephyr.jcl.java.nio.channels.Selector;
+import org.jvnet.zephyr.jcl.java.nio.channels.ServerSocketChannel;
+import org.jvnet.zephyr.jcl.java.nio.channels.SocketChannel;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.ServiceLoader;

 import java.io.IOException;
 import java.net.ProtocolFamily;
-import java.nio.channels.*;
+import java.nio.channels.Channel;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.Iterator;
-import java.util.ServiceLoader;
 import java.util.ServiceConfigurationError;
-import sun.security.action.GetPropertyAction;


 /**
@@ -47,12 +55,12 @@
  * the default provider as specified below.
  *
  * <p> The system-wide default provider is used by the static <tt>open</tt>
- * methods of the {@link java.nio.channels.DatagramChannel#open
- * DatagramChannel}, {@link java.nio.channels.Pipe#open Pipe}, {@link
- * java.nio.channels.Selector#open Selector}, {@link
- * java.nio.channels.ServerSocketChannel#open ServerSocketChannel}, and {@link
- * java.nio.channels.SocketChannel#open SocketChannel} classes.  It is also
- * used by the {@link java.lang.System#inheritedChannel System.inheritedChannel()}
+ * methods of the {@link DatagramChannel#open
+ * DatagramChannel}, {@link Pipe#open Pipe}, {@link
+ * Selector#open Selector}, {@link
+ * ServerSocketChannel#open ServerSocketChannel}, and {@link
+ * SocketChannel#open SocketChannel} classes.  It is also
+ * used by the {@link System#inheritedChannel System.inheritedChannel()}
  * method. A program may make use of a provider other than the default provider
  * by instantiating that provider and then directly invoking the <tt>open</tt>
  * methods defined in this class.
@@ -85,7 +93,7 @@
     }

     private static boolean loadProviderFromProperty() {
-        String cn = System.getProperty("java.nio.channels.spi.SelectorProvider");
+        String cn = System.getProperty("org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider");
         if (cn == null)
             return false;
         try {
@@ -136,7 +144,7 @@
      * <ol>
      *
      *   <li><p> If the system property
-     *   <tt>java.nio.channels.spi.SelectorProvider</tt> is defined then it is
+     *   <tt>org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider</tt> is defined then it is
      *   taken to be the fully-qualified name of a concrete provider class.
      *   The class is loaded and instantiated; if this process fails then an
      *   unspecified error is thrown.  </p></li>
@@ -144,7 +152,7 @@
      *   <li><p> If a provider class has been installed in a jar file that is
      *   visible to the system class loader, and that jar file contains a
      *   provider-configuration file named
-     *   <tt>java.nio.channels.spi.SelectorProvider</tt> in the resource
+     *   <tt>org.jvnet.zephyr.jcl.java.nio.channels.spi.SelectorProvider</tt> in the resource
      *   directory <tt>META-INF/services</tt>, then the first class name
      *   specified in that file is taken.  The class is loaded and
      *   instantiated; if this process fails then an unspecified error is
@@ -172,7 +180,7 @@
                                 return provider;
                             if (loadProviderAsService())
                                 return provider;
-                            provider = sun.nio.ch.DefaultSelectorProvider.create();
+                            provider = new DefaultSelectorProvider();
                             return provider;
                         }
                     });
@@ -258,19 +266,19 @@
      * <ul>
      *
      *  <li><p> If the inherited channel represents a stream-oriented connected
-     *  socket then a {@link java.nio.channels.SocketChannel SocketChannel} is
+     *  socket then a {@link SocketChannel SocketChannel} is
      *  returned. The socket channel is, at least initially, in blocking
      *  mode, bound to a socket address, and connected to a peer.
      *  </p></li>
      *
      *  <li><p> If the inherited channel represents a stream-oriented listening
-     *  socket then a {@link java.nio.channels.ServerSocketChannel
+     *  socket then a {@link ServerSocketChannel
      *  ServerSocketChannel} is returned. The server-socket channel is, at
      *  least initially, in blocking mode, and bound to a socket address.
      *  </p></li>
      *
      *  <li><p> If the inherited channel is a datagram-oriented socket
-     *  then a {@link java.nio.channels.DatagramChannel DatagramChannel} is
+     *  then a {@link DatagramChannel DatagramChannel} is
      *  returned. The datagram channel is, at least initially, in blocking
      *  mode, and bound to a socket address.
      *  </p></li>
diff -r 55f6804b4352 src/share/classes/java/util/AbstractCollection.java
--- a/src/share/classes/java/util/AbstractCollection.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/AbstractCollection.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * This class provides a skeletal implementation of the <tt>Collection</tt>
@@ -312,9 +312,11 @@
      * @see #contains(Object)
      */
     public boolean containsAll(Collection<?> c) {
-        for (Object e : c)
+        for (Iterator<?> iterator = c.iterator(); iterator.hasNext(); ) {
+            Object e = iterator.next();
             if (!contains(e))
                 return false;
+        }
         return true;
     }

@@ -338,9 +340,11 @@
      */
     public boolean addAll(Collection<? extends E> c) {
         boolean modified = false;
-        for (E e : c)
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             if (add(e))
                 modified = true;
+        }
         return modified;
     }

diff -r 55f6804b4352 src/share/classes/java/util/AbstractList.java
--- a/src/share/classes/java/util/AbstractList.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/AbstractList.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,11 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;
+import java.util.RandomAccess;

 /**
  * This class provides a skeletal implementation of the {@link List}
@@ -256,7 +260,8 @@
     public boolean addAll(int index, Collection<? extends E> c) {
         rangeCheckForAdd(index);
         boolean modified = false;
-        for (E e : c) {
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             add(index++, e);
             modified = true;
         }
@@ -537,8 +542,10 @@
      */
     public int hashCode() {
         int hashCode = 1;
-        for (E e : this)
+        for (Iterator<E> iterator = this.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
+        }
         return hashCode;
     }

diff -r 55f6804b4352 src/share/classes/java/util/AbstractMap.java
--- a/src/share/classes/java/util/AbstractMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/AbstractMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,8 +23,7 @@
  * questions.
  */

-package java.util;
-import java.util.Map.Entry;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * This class provides a skeletal implementation of the <tt>Map</tt>
@@ -269,8 +268,11 @@
      * @throws IllegalArgumentException      {@inheritDoc}
      */
     public void putAll(Map<? extends K, ? extends V> m) {
-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> iterator = m.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Map.Entry<? extends K, ? extends V> e = iterator.next();
             put(e.getKey(), e.getValue());
+        }
     }

     /**
diff -r 55f6804b4352 src/share/classes/java/util/AbstractQueue.java
--- a/src/share/classes/java/util/AbstractQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/AbstractQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,9 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.NoSuchElementException;

 /**
  * This class provides skeletal implementations of some {@link Queue}
@@ -183,9 +185,11 @@
         if (c == this)
             throw new IllegalArgumentException();
         boolean modified = false;
-        for (E e : c)
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             if (add(e))
                 modified = true;
+        }
         return modified;
     }

diff -r 55f6804b4352 src/share/classes/java/util/AbstractSequentialList.java
--- a/src/share/classes/java/util/AbstractSequentialList.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/AbstractSequentialList.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.NoSuchElementException;

 /**
  * This class provides a skeletal implementation of the <tt>List</tt>
diff -r 55f6804b4352 src/share/classes/java/util/AbstractSet.java
--- a/src/share/classes/java/util/AbstractSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/AbstractSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * This class provides a skeletal implementation of the <tt>Set</tt>
diff -r 55f6804b4352 src/share/classes/java/util/ArrayDeque.java
--- a/src/share/classes/java/util/ArrayDeque.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/ArrayDeque.java	Fri Jul 31 15:48:18 2015 +0300
@@ -32,8 +32,14 @@
  * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
  */

-package java.util;
-import java.io.*;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * Resizable-array implementation of the {@link Deque} interface.  Array
diff -r 55f6804b4352 src/share/classes/java/util/ArrayList.java
--- a/src/share/classes/java/util/ArrayList.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/ArrayList.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,11 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;
+import java.util.RandomAccess;

 /**
  * Resizable-array implementation of the <tt>List</tt> interface.  Implements
diff -r 55f6804b4352 src/share/classes/java/util/Arrays.java
--- a/src/share/classes/java/util/Arrays.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Arrays.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,9 +23,10 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

-import java.lang.reflect.*;
+import java.lang.reflect.Array;
+import java.util.RandomAccess;

 /**
  * This class contains various methods for manipulating arrays (such as
@@ -387,7 +388,7 @@
         private static final boolean userRequested =
             java.security.AccessController.doPrivileged(
                 new sun.security.action.GetBooleanAction(
-                    "java.util.Arrays.useLegacyMergeSort")).booleanValue();
+                    "org.jvnet.zephyr.jcl.java.util.Arrays.useLegacyMergeSort")).booleanValue();
     }

     /*
diff -r 55f6804b4352 src/share/classes/java/util/Collection.java
--- a/src/share/classes/java/util/Collection.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Collection.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.java.lang.Iterable;

 /**
  * The root interface in the <i>collection hierarchy</i>.  A collection
diff -r 55f6804b4352 src/share/classes/java/util/Collections.java
--- a/src/share/classes/java/util/Collections.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Collections.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,11 +23,15 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.io.IOException;
+import java.io.ObjectOutputStream;
 import java.io.Serializable;
-import java.io.ObjectOutputStream;
-import java.io.IOException;
 import java.lang.reflect.Array;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;
+import java.util.RandomAccess;

 /**
  * This class consists exclusively of static methods that operate on or return
@@ -1452,7 +1456,8 @@
              * when o is a Map.Entry, and calls o.setValue.
              */
             public boolean containsAll(Collection<?> coll) {
-                for (Object e : coll) {
+                for (Iterator<?> iterator = coll.iterator(); iterator.hasNext(); ) {
+                    Object e = iterator.next();
                     if (!contains(e)) // Invokes safe contains() above
                         return false;
                 }
@@ -2694,8 +2699,10 @@
                 checked.add(
                     new AbstractMap.SimpleImmutableEntry<>((K) k, (V) v));
             }
-            for (Map.Entry<K,V> e : checked)
+            for (Iterator<Map.Entry<K, V>> iterator = checked.iterator(); iterator.hasNext(); ) {
+                Map.Entry<K, V> e = iterator.next();
                 m.put(e.getKey(), e.getValue());
+            }
         }

         private transient Set<Map.Entry<K,V>> entrySet = null;
@@ -2807,9 +2814,11 @@
              * method senses when o is a Map.Entry, and calls o.setValue.
              */
             public boolean containsAll(Collection<?> c) {
-                for (Object o : c)
+                for (Iterator<?> iterator = c.iterator(); iterator.hasNext(); ) {
+                    Object o = iterator.next();
                     if (!contains(o)) // Invokes safe contains() above
                         return false;
+                }
                 return true;
             }

@@ -3711,13 +3720,17 @@
     public static int frequency(Collection<?> c, Object o) {
         int result = 0;
         if (o == null) {
-            for (Object e : c)
+            for (Iterator<?> iterator = c.iterator(); iterator.hasNext(); ) {
+                Object e = iterator.next();
                 if (e == null)
                     result++;
+            }
         } else {
-            for (Object e : c)
+            for (Iterator<?> iterator = c.iterator(); iterator.hasNext(); ) {
+                Object e = iterator.next();
                 if (o.equals(e))
                     result++;
+            }
         }
         return result;
     }
@@ -3801,7 +3814,8 @@
             }
         }

-        for (Object e : iterate) {
+        for (Iterator<?> iterator = iterate.iterator(); iterator.hasNext(); ) {
+            Object e = iterator.next();
             if (contains.contains(e)) {
                // Found a common element. Collections are not disjoint.
                 return false;
diff -r 55f6804b4352 src/share/classes/java/util/ComparableTimSort.java
--- a/src/share/classes/java/util/ComparableTimSort.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/ComparableTimSort.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * This is a near duplicate of {@link TimSort}, modified for use with
@@ -139,7 +139,7 @@
     /*
      * The next two methods (which are package private and static) constitute
      * the entire API of this class.  Each of these methods obeys the contract
-     * of the public method with the same signature in java.util.Arrays.
+     * of the public method with the same signature in org.jvnet.zephyr.jcl.java.util.Arrays.
      */

     static void sort(Object[] a) {
diff -r 55f6804b4352 src/share/classes/java/util/Comparator.java
--- a/src/share/classes/java/util/Comparator.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Comparator.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * A comparison function, which imposes a <i>total ordering</i> on some
diff -r 55f6804b4352 src/share/classes/java/util/Deque.java
--- a/src/share/classes/java/util/Deque.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Deque.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,7 @@
  * at http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * A linear collection that supports element insertion and removal at
@@ -106,27 +106,27 @@
  *    <td ALIGN=CENTER> <b>Equivalent <tt>Deque</tt> Method</b></td>
  *  </tr>
  *  <tr>
- *    <td>{@link java.util.Queue#add add(e)}</td>
+ *    <td>{@link Queue#add add(e)}</td>
  *    <td>{@link #addLast addLast(e)}</td>
  *  </tr>
  *  <tr>
- *    <td>{@link java.util.Queue#offer offer(e)}</td>
+ *    <td>{@link Queue#offer offer(e)}</td>
  *    <td>{@link #offerLast offerLast(e)}</td>
  *  </tr>
  *  <tr>
- *    <td>{@link java.util.Queue#remove remove()}</td>
+ *    <td>{@link Queue#remove remove()}</td>
  *    <td>{@link #removeFirst removeFirst()}</td>
  *  </tr>
  *  <tr>
- *    <td>{@link java.util.Queue#poll poll()}</td>
+ *    <td>{@link Queue#poll poll()}</td>
  *    <td>{@link #pollFirst pollFirst()}</td>
  *  </tr>
  *  <tr>
- *    <td>{@link java.util.Queue#element element()}</td>
+ *    <td>{@link Queue#element element()}</td>
  *    <td>{@link #getFirst getFirst()}</td>
  *  </tr>
  *  <tr>
- *    <td>{@link java.util.Queue#peek peek()}</td>
+ *    <td>{@link Queue#peek peek()}</td>
  *    <td>{@link #peek peekFirst()}</td>
  *  </tr>
  * </table>
diff -r 55f6804b4352 src/share/classes/java/util/DualPivotQuicksort.java
--- a/src/share/classes/java/util/DualPivotQuicksort.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/DualPivotQuicksort.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * This class implements the Dual-Pivot Quicksort algorithm by
diff -r 55f6804b4352 src/share/classes/java/util/EnumMap.java
--- a/src/share/classes/java/util/EnumMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/EnumMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,11 +23,13 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

-import java.util.Map.Entry;
 import sun.misc.SharedSecrets;

+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;
+
 /**
  * A specialized {@link Map} implementation for use with enum type keys.  All
  * of the keys in an enum map must come from a single enum type that is
@@ -112,7 +114,7 @@
         }

         public String toString() {
-            return "java.util.EnumMap.NULL";
+            return "org.jvnet.zephyr.jcl.java.util.EnumMap.NULL";
         }
     };

diff -r 55f6804b4352 src/share/classes/java/util/EnumSet.java
--- a/src/share/classes/java/util/EnumSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/EnumSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,10 +23,12 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 import sun.misc.SharedSecrets;

+import java.util.ConcurrentModificationException;
+
 /**
  * A specialized {@link Set} implementation for use with enum types.  All of
  * the elements in an enum set must come from a single enum type that is
diff -r 55f6804b4352 src/share/classes/java/util/HashMap.java
--- a/src/share/classes/java/util/HashMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/HashMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,8 +23,13 @@
  * questions.
  */

-package java.util;
-import java.io.*;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.io.IOException;
+import java.io.InvalidObjectException;
+import java.io.Serializable;
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * Hash table based implementation of the <tt>Map</tt> interface.  This
@@ -551,8 +556,11 @@
     }

     private void putAllForCreate(Map<? extends K, ? extends V> m) {
-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> iterator = m.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Map.Entry<? extends K, ? extends V> e = iterator.next();
             putForCreate(e.getKey(), e.getValue());
+        }
     }

     /**
@@ -639,8 +647,11 @@
                 resize(newCapacity);
         }

-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> iterator = m.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Map.Entry<? extends K, ? extends V> e = iterator.next();
             put(e.getKey(), e.getValue());
+        }
     }

     /**
@@ -1124,7 +1135,8 @@

         // Write out keys and values (alternating)
         if (size > 0) {
-            for(Map.Entry<K,V> e : entrySet0()) {
+            for (Iterator<Map.Entry<K, V>> iterator = entrySet0().iterator(); iterator.hasNext(); ) {
+                Map.Entry<K, V> e = iterator.next();
                 s.writeObject(e.getKey());
                 s.writeObject(e.getValue());
             }
diff -r 55f6804b4352 src/share/classes/java/util/HashSet.java
--- a/src/share/classes/java/util/HashSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/HashSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;

 /**
  * This class implements the <tt>Set</tt> interface, backed by a hash table
@@ -280,8 +282,10 @@
         s.writeInt(map.size());

         // Write out all elements in the proper order.
-        for (E e : map.keySet())
+        for (Iterator<E> iterator = map.keySet().iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             s.writeObject(e);
+        }
     }

     /**
diff -r 55f6804b4352 src/share/classes/java/util/Hashtable.java
--- a/src/share/classes/java/util/Hashtable.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Hashtable.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,8 +23,16 @@
  * questions.
  */

-package java.util;
-import java.io.*;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.java.util.concurrent.ConcurrentHashMap;
+
+import java.io.IOException;
+import java.io.StreamCorruptedException;
+import java.util.ConcurrentModificationException;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;

 /**
  * This class implements a hash table, which maps keys to values. Any
@@ -107,7 +115,7 @@
  * thread-safe implementation is not needed, it is recommended to use
  * {@link HashMap} in place of {@code Hashtable}.  If a thread-safe
  * highly-concurrent implementation is desired, then it is recommended
- * to use {@link java.util.concurrent.ConcurrentHashMap} in place of
+ * to use {@link ConcurrentHashMap} in place of
  * {@code Hashtable}.
  *
  * @author  Arthur van Hoff
@@ -583,8 +591,11 @@
      * @since 1.2
      */
     public synchronized void putAll(Map<? extends K, ? extends V> t) {
-        for (Map.Entry<? extends K, ? extends V> e : t.entrySet())
+        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> iterator = t.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Map.Entry<? extends K, ? extends V> e = iterator.next();
             put(e.getKey(), e.getValue());
+        }
     }

     /**
diff -r 55f6804b4352 src/share/classes/java/util/IdentityHashMap.java
--- a/src/share/classes/java/util/IdentityHashMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/IdentityHashMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,8 +23,11 @@
  * questions.
  */

-package java.util;
-import java.io.*;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.io.IOException;
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * This class implements the <tt>Map</tt> interface with a hash table, using
@@ -500,8 +503,11 @@
         if (n > threshold) // conservatively pre-expand
             resize(capacity(n));

-        for (Entry<? extends K, ? extends V> e : m.entrySet())
+        for (Iterator<? extends Entry<? extends K, ? extends V>> iterator = m.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Entry<? extends K, ? extends V> e = iterator.next();
             put(e.getKey(), e.getValue());
+        }
     }

     /**
@@ -998,8 +1004,10 @@
         }
         public int hashCode() {
             int result = 0;
-            for (K key : this)
+            for (Iterator<K> iterator = this.iterator(); iterator.hasNext(); ) {
+                K key = iterator.next();
                 result += System.identityHashCode(key);
+            }
             return result;
         }
     }
diff -r 55f6804b4352 src/share/classes/java/util/Iterator.java
--- a/src/share/classes/java/util/Iterator.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Iterator.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,12 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.java.lang.Iterable;
+
+import java.util.Enumeration;
+import java.util.NoSuchElementException;

 /**
  * An iterator over a collection.  {@code Iterator} takes the place of
diff -r 55f6804b4352 src/share/classes/java/util/JumboEnumSet.java
--- a/src/share/classes/java/util/JumboEnumSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/JumboEnumSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,10 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * Private implementation class for EnumSet, for "jumbo" enum types
diff -r 55f6804b4352 src/share/classes/java/util/LinkedHashMap.java
--- a/src/share/classes/java/util/LinkedHashMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/LinkedHashMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,8 +23,10 @@
  * questions.
  */

-package java.util;
-import java.io.*;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * <p>Hash table and linked list implementation of the <tt>Map</tt> interface,
diff -r 55f6804b4352 src/share/classes/java/util/LinkedHashSet.java
--- a/src/share/classes/java/util/LinkedHashSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/LinkedHashSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;

 /**
  * <p>Hash table and linked list implementation of the <tt>Set</tt> interface,
diff -r 55f6804b4352 src/share/classes/java/util/LinkedList.java
--- a/src/share/classes/java/util/LinkedList.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/LinkedList.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,10 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * Doubly-linked list implementation of the {@code List} and {@code Deque}
diff -r 55f6804b4352 src/share/classes/java/util/List.java
--- a/src/share/classes/java/util/List.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/List.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * An ordered collection (also known as a <i>sequence</i>).  The user of this
diff -r 55f6804b4352 src/share/classes/java/util/ListIterator.java
--- a/src/share/classes/java/util/ListIterator.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/ListIterator.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,10 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.Enumeration;
+import java.util.NoSuchElementException;

 /**
  * An iterator for lists that allows the programmer
diff -r 55f6804b4352 src/share/classes/java/util/Map.java
--- a/src/share/classes/java/util/Map.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Map.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * An object that maps keys to values.  A map cannot contain duplicate keys;
diff -r 55f6804b4352 src/share/classes/java/util/NavigableMap.java
--- a/src/share/classes/java/util/NavigableMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/NavigableMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,7 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * A {@link SortedMap} extended with navigation methods returning the
diff -r 55f6804b4352 src/share/classes/java/util/NavigableSet.java
--- a/src/share/classes/java/util/NavigableSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/NavigableSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,7 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * A {@link SortedSet} extended with navigation methods reporting
diff -r 55f6804b4352 src/share/classes/java/util/Objects.java
--- a/src/share/classes/java/util/Objects.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Objects.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * This class consists of {@code static} utility methods for operating
@@ -35,7 +35,7 @@
  */
 public final class Objects {
     private Objects() {
-        throw new AssertionError("No java.util.Objects instances for you!");
+        throw new AssertionError("No org.jvnet.zephyr.jcl.java.util.Objects instances for you!");
     }

     /**
diff -r 55f6804b4352 src/share/classes/java/util/PriorityQueue.java
--- a/src/share/classes/java/util/PriorityQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/PriorityQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,12 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.java.util.concurrent.PriorityBlockingQueue;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * An unbounded priority {@linkplain Queue queue} based on a priority heap.
@@ -60,7 +65,7 @@
  * Multiple threads should not access a {@code PriorityQueue}
  * instance concurrently if any of the threads modifies the queue.
  * Instead, use the thread-safe {@link
- * java.util.concurrent.PriorityBlockingQueue} class.
+ * PriorityBlockingQueue} class.
  *
  * <p>Implementation note: this implementation provides
  * O(log(n)) time for the enqueing and dequeing methods
diff -r 55f6804b4352 src/share/classes/java/util/Properties.java
--- a/src/share/classes/java/util/Properties.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Properties.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,17 +23,20 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

+import java.io.BufferedWriter;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
 import java.io.PrintStream;
 import java.io.PrintWriter;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.io.Reader;
 import java.io.Writer;
-import java.io.OutputStreamWriter;
-import java.io.BufferedWriter;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.InvalidPropertiesFormatException;

 /**
  * The <code>Properties</code> class represents a persistent set of
diff -r 55f6804b4352 src/share/classes/java/util/Queue.java
--- a/src/share/classes/java/util/Queue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Queue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,18 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.java.util.concurrent.ArrayBlockingQueue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.BlockingQueue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.LinkedBlockingQueue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.PriorityBlockingQueue;
+
+import java.util.NoSuchElementException;

 /**
  * A collection designed for holding elements prior to processing.
- * Besides basic {@link java.util.Collection Collection} operations,
+ * Besides basic {@link Collection Collection} operations,
  * queues provide additional insertion, extraction, and inspection
  * operations.  Each of these methods exists in two forms: one throws
  * an exception if the operation fails, the other returns a special
@@ -85,7 +92,7 @@
  *
  * <p>The {@link #offer offer} method inserts an element if possible,
  * otherwise returning <tt>false</tt>.  This differs from the {@link
- * java.util.Collection#add Collection.add} method, which can fail to
+ * Collection#add Collection.add} method, which can fail to
  * add an element only by throwing an unchecked exception.  The
  * <tt>offer</tt> method is designed for use when failure is a normal,
  * rather than exceptional occurrence, for example, in fixed-capacity
@@ -106,7 +113,7 @@
  * <p>The <tt>Queue</tt> interface does not define the <i>blocking queue
  * methods</i>, which are common in concurrent programming.  These methods,
  * which wait for elements to appear or for space to become available, are
- * defined in the {@link java.util.concurrent.BlockingQueue} interface, which
+ * defined in the {@link BlockingQueue} interface, which
  * extends this interface.
  *
  * <p><tt>Queue</tt> implementations generally do not allow insertion
@@ -129,14 +136,14 @@
  * <a href="{@docRoot}/../technotes/guides/collections/index.html">
  * Java Collections Framework</a>.
  *
- * @see java.util.Collection
+ * @see Collection
  * @see LinkedList
  * @see PriorityQueue
- * @see java.util.concurrent.LinkedBlockingQueue
- * @see java.util.concurrent.BlockingQueue
- * @see java.util.concurrent.ArrayBlockingQueue
- * @see java.util.concurrent.LinkedBlockingQueue
- * @see java.util.concurrent.PriorityBlockingQueue
+ * @see LinkedBlockingQueue
+ * @see BlockingQueue
+ * @see ArrayBlockingQueue
+ * @see LinkedBlockingQueue
+ * @see PriorityBlockingQueue
  * @since 1.5
  * @author Doug Lea
  * @param <E> the type of elements held in this collection
diff -r 55f6804b4352 src/share/classes/java/util/Random.java
--- a/src/share/classes/java/util/Random.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Random.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,11 +23,20 @@
  * questions.
  */

-package java.util;
-import java.io.*;
-import java.util.concurrent.atomic.AtomicLong;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.concurrent.ThreadLocalRandom;
+import org.jvnet.zephyr.jcl.java.util.concurrent.atomic.AtomicLong;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Lock;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
 import sun.misc.Unsafe;

+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+
 /**
  * An instance of this class is used to generate a stream of
  * pseudorandom numbers. The class uses a 48-bit seed, which is
@@ -50,14 +59,14 @@
  * <p>
  * Many applications will find the method {@link Math#random} simpler to use.
  *
- * <p>Instances of {@code java.util.Random} are threadsafe.
- * However, the concurrent use of the same {@code java.util.Random}
+ * <p>Instances of {@code Random} are threadsafe.
+ * However, the concurrent use of the same {@code Random}
  * instance across threads may encounter contention and consequent
  * poor performance. Consider instead using
- * {@link java.util.concurrent.ThreadLocalRandom} in multithreaded
+ * {@link ThreadLocalRandom} in multithreaded
  * designs.
  *
- * <p>Instances of {@code java.util.Random} are not cryptographically
+ * <p>Instances of {@code Random} are not cryptographically
  * secure.  Consider instead using {@link java.security.SecureRandom} to
  * get a cryptographically secure pseudo-random number generator for use
  * by security-sensitive applications.
@@ -81,6 +90,8 @@
     private static final long addend = 0xBL;
     private static final long mask = (1L << 48) - 1;

+    private final Lock lock = new ReentrantLock();
+
     /**
      * Creates a new random number generator. This constructor sets
      * the seed of the random number generator to a value very likely
@@ -150,9 +161,14 @@
      *
      * @param seed the initial seed
      */
-    synchronized public void setSeed(long seed) {
-        this.seed.set(initialScramble(seed));
-        haveNextNextGaussian = false;
+    public void setSeed(long seed) {
+        lock.lock();
+        try {
+            this.seed.set(initialScramble(seed));
+            haveNextNextGaussian = false;
+        } finally {
+            lock.unlock();
+        }
     }

     /**
@@ -493,22 +509,27 @@
      *         standard deviation {@code 1.0} from this random number
      *         generator's sequence
      */
-    synchronized public double nextGaussian() {
-        // See Knuth, ACP, Section 3.4.1 Algorithm C.
-        if (haveNextNextGaussian) {
-            haveNextNextGaussian = false;
-            return nextNextGaussian;
-        } else {
-            double v1, v2, s;
-            do {
-                v1 = 2 * nextDouble() - 1; // between -1 and 1
-                v2 = 2 * nextDouble() - 1; // between -1 and 1
-                s = v1 * v1 + v2 * v2;
-            } while (s >= 1 || s == 0);
-            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
-            nextNextGaussian = v2 * multiplier;
-            haveNextNextGaussian = true;
-            return v1 * multiplier;
+    public double nextGaussian() {
+        lock.lock();
+        try {
+            // See Knuth, ACP, Section 3.4.1 Algorithm C.
+            if (haveNextNextGaussian) {
+                haveNextNextGaussian = false;
+                return nextNextGaussian;
+            } else {
+                double v1, v2, s;
+                do {
+                    v1 = 2 * nextDouble() - 1; // between -1 and 1
+                    v2 = 2 * nextDouble() - 1; // between -1 and 1
+                    s = v1 * v1 + v2 * v2;
+                } while (s >= 1 || s == 0);
+                double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
+                nextNextGaussian = v2 * multiplier;
+                haveNextNextGaussian = true;
+                return v1 * multiplier;
+            }
+        } finally {
+            lock.unlock();
         }
     }

@@ -551,23 +572,27 @@
     /**
      * Save the {@code Random} instance to a stream.
      */
-    synchronized private void writeObject(ObjectOutputStream s)
+    private void writeObject(ObjectOutputStream s)
         throws IOException {
+        lock.lock();
+        try {
+            // set the values of the Serializable fields
+            ObjectOutputStream.PutField fields = s.putFields();

-        // set the values of the Serializable fields
-        ObjectOutputStream.PutField fields = s.putFields();
+            // The seed is serialized as a long for historical reasons.
+            fields.put("seed", seed.get());
+            fields.put("nextNextGaussian", nextNextGaussian);
+            fields.put("haveNextNextGaussian", haveNextNextGaussian);

-        // The seed is serialized as a long for historical reasons.
-        fields.put("seed", seed.get());
-        fields.put("nextNextGaussian", nextNextGaussian);
-        fields.put("haveNextNextGaussian", haveNextNextGaussian);
-
-        // save them
-        s.writeFields();
+            // save them
+            s.writeFields();
+        } finally {
+            lock.unlock();
+        }
     }

     // Support for resetting seed while deserializing
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long seedOffset;
     static {
         try {
diff -r 55f6804b4352 src/share/classes/java/util/RegularEnumSet.java
--- a/src/share/classes/java/util/RegularEnumSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/RegularEnumSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,10 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * Private implementation class for EnumSet, for "regular sized" enum types
diff -r 55f6804b4352 src/share/classes/java/util/ServiceLoader.java
--- a/src/share/classes/java/util/ServiceLoader.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/ServiceLoader.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,18 +23,19 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import org.jvnet.zephyr.jcl.java.lang.Iterable;
+import org.jvnet.zephyr.jcl.java.lang.Thread;

 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.net.URL;
-import java.util.ArrayList;
 import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.List;
 import java.util.NoSuchElementException;
+import java.util.ServiceConfigurationError;


 /**
@@ -397,8 +398,8 @@
      *
      * <p> To achieve laziness the actual work of parsing the available
      * provider-configuration files and instantiating providers must be done by
-     * the iterator itself.  Its {@link java.util.Iterator#hasNext hasNext} and
-     * {@link java.util.Iterator#next next} methods can therefore throw a
+     * the iterator itself.  Its {@link Iterator#hasNext hasNext} and
+     * {@link Iterator#next next} methods can therefore throw a
      * {@link ServiceConfigurationError} if a provider-configuration file
      * violates the specified format, or if it names a provider class that
      * cannot be found and instantiated, or if the result of instantiating the
@@ -421,7 +422,7 @@
      * fail silently.</blockquote>
      *
      * <p> The iterator returned by this method does not support removal.
-     * Invoking its {@link java.util.Iterator#remove() remove} method will
+     * Invoking its {@link Iterator#remove() remove} method will
      * cause an {@link UnsupportedOperationException} to be thrown.
      *
      * @return  An iterator that lazily loads providers for this loader's
@@ -475,7 +476,7 @@

     /**
      * Creates a new service loader for the given service type, using the
-     * current thread's {@linkplain java.lang.Thread#getContextClassLoader
+     * current thread's {@linkplain Thread#getContextClassLoader
      * context class loader}.
      *
      * <p> An invocation of this convenience method of the form
@@ -539,7 +540,7 @@
      * @return  A descriptive string
      */
     public String toString() {
-        return "java.util.ServiceLoader[" + service.getName() + "]";
+        return "org.jvnet.zephyr.jcl.java.util.ServiceLoader[" + service.getName() + "]";
     }

 }
diff -r 55f6804b4352 src/share/classes/java/util/Set.java
--- a/src/share/classes/java/util/Set.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Set.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * A collection that contains no duplicate elements.  More formally, sets
diff -r 55f6804b4352 src/share/classes/java/util/SortedMap.java
--- a/src/share/classes/java/util/SortedMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/SortedMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.NoSuchElementException;

 /**
  * A {@link Map} that further provides a <em>total ordering</em> on its keys.
diff -r 55f6804b4352 src/share/classes/java/util/SortedSet.java
--- a/src/share/classes/java/util/SortedSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/SortedSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.NoSuchElementException;

 /**
  * A {@link Set} that further provides a <i>total ordering</i> on its elements.
diff -r 55f6804b4352 src/share/classes/java/util/Stack.java
--- a/src/share/classes/java/util/Stack.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Stack.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,9 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.EmptyStackException;

 /**
  * The <code>Stack</code> class represents a last-in-first-out
@@ -61,7 +63,7 @@
      *
      * @param   item   the item to be pushed onto this stack.
      * @return  the <code>item</code> argument.
-     * @see     java.util.Vector#addElement
+     * @see     Vector#addElement
      */
     public E push(E item) {
         addElement(item);
diff -r 55f6804b4352 src/share/classes/java/util/TimSort.java
--- a/src/share/classes/java/util/TimSort.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/TimSort.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,7 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

 /**
  * A stable, adaptive, iterative mergesort that requires far fewer than
@@ -166,7 +166,7 @@
     /*
      * The next two methods (which are package private and static) constitute
      * the entire API of this class.  Each of these methods obeys the contract
-     * of the public method with the same signature in java.util.Arrays.
+     * of the public method with the same signature in org.jvnet.zephyr.jcl.java.util.Arrays.
      */

     static <T> void sort(T[] a, Comparator<? super T> c) {
diff -r 55f6804b4352 src/share/classes/java/util/TreeMap.java
--- a/src/share/classes/java/util/TreeMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/TreeMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,11 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.io.IOException;
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * A Red-Black tree based {@link NavigableMap} implementation.
diff -r 55f6804b4352 src/share/classes/java/util/TreeSet.java
--- a/src/share/classes/java/util/TreeSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/TreeSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,10 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * A {@link NavigableSet} implementation based on a {@link TreeMap}.
@@ -505,8 +508,10 @@
         s.writeInt(m.size());

         // Write out all elements in the proper order.
-        for (E e : m.keySet())
+        for (Iterator<E> iterator = m.keySet().iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             s.writeObject(e);
+        }
     }

     /**
diff -r 55f6804b4352 src/share/classes/java/util/Vector.java
--- a/src/share/classes/java/util/Vector.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/Vector.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,7 +23,12 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.util.ConcurrentModificationException;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;
+import java.util.RandomAccess;

 /**
  * The {@code Vector} class implements a growable array of
diff -r 55f6804b4352 src/share/classes/java/util/WeakHashMap.java
--- a/src/share/classes/java/util/WeakHashMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/WeakHashMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,9 +23,12 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;
+
+import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
-import java.lang.ref.ReferenceQueue;
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;


 /**
@@ -125,7 +128,7 @@
  * @author      Josh Bloch
  * @author      Mark Reinhold
  * @since       1.2
- * @see         java.util.HashMap
+ * @see         HashMap
  * @see         java.lang.ref.WeakReference
  */
 public class WeakHashMap<K,V>
@@ -637,8 +640,11 @@
                 resize(newCapacity);
         }

-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> iterator = m.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Map.Entry<? extends K, ? extends V> e = iterator.next();
             put(e.getKey(), e.getValue());
+        }
     }

     /**
@@ -1053,8 +1059,10 @@

         private List<Map.Entry<K,V>> deepCopy() {
             List<Map.Entry<K,V>> list = new ArrayList<>(size());
-            for (Map.Entry<K,V> e : this)
+            for (Iterator<Map.Entry<K, V>> iterator = this.iterator(); iterator.hasNext(); ) {
+                Map.Entry<K, V> e = iterator.next();
                 list.add(new AbstractMap.SimpleEntry<>(e));
+            }
             return list;
         }

diff -r 55f6804b4352 src/share/classes/java/util/XMLUtils.java
--- a/src/share/classes/java/util/XMLUtils.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/XMLUtils.java	Fri Jul 31 15:48:18 2015 +0300
@@ -23,16 +23,33 @@
  * questions.
  */

-package java.util;
+package org.jvnet.zephyr.jcl.java.util;

-import java.io.*;
-import org.xml.sax.*;
-import org.xml.sax.helpers.*;
-import org.w3c.dom.*;
-import javax.xml.parsers.*;
-import javax.xml.transform.*;
-import javax.xml.transform.dom.*;
-import javax.xml.transform.stream.*;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.StringReader;
+import java.util.InvalidPropertiesFormatException;

 /**
  * A class used to aid in Properties load and save in XML. Keeping this
@@ -142,7 +159,8 @@
         }

         synchronized (props) {
-            for (String key : props.stringPropertyNames()) {
+            for (Iterator<String> iterator = props.stringPropertyNames().iterator(); iterator.hasNext(); ) {
+                String key = iterator.next();
                 Element entry = (Element)properties.appendChild(
                     doc.createElement("entry"));
                 entry.setAttribute("key", key);
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ArrayBlockingQueue.java
--- a/src/share/classes/java/util/concurrent/ArrayBlockingQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ArrayBlockingQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,9 +33,15 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.locks.*;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Condition;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
+import java.util.NoSuchElementException;

 /**
  * A bounded {@linkplain BlockingQueue blocking queue} backed by an
@@ -254,7 +260,8 @@
         try {
             int i = 0;
             try {
-                for (E e : c) {
+                for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+                    E e = iterator.next();
                     checkNotNull(e);
                     items[i++] = e;
                 }
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/BlockingDeque.java
--- a/src/share/classes/java/util/concurrent/BlockingDeque.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/BlockingDeque.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,8 +33,12 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.util.Deque;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+
+import java.util.NoSuchElementException;

 /**
  * A {@link Deque} that additionally supports blocking operations that wait
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/BlockingQueue.java
--- a/src/share/classes/java/util/concurrent/BlockingQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/BlockingQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,13 +33,13 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.Collection;
-import java.util.Queue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Queue;

 /**
- * A {@link java.util.Queue} that additionally supports operations
+ * A {@link Queue} that additionally supports operations
  * that wait for the queue to become non-empty when retrieving an
  * element, and wait for space to become available in the queue when
  * storing an element.
@@ -99,7 +99,7 @@
  *
  * <p> <tt>BlockingQueue</tt> implementations are designed to be used
  * primarily for producer-consumer queues, but additionally support
- * the {@link java.util.Collection} interface.  So, for example, it is
+ * the {@link Collection} interface.  So, for example, it is
  * possible to remove an arbitrary element from a queue using
  * <tt>remove(x)</tt>. However, such operations are in general
  * <em>not</em> performed very efficiently, and are intended for only
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentHashMap.java
--- a/src/share/classes/java/util/concurrent/ConcurrentHashMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentHashMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,19 +33,31 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.locks.*;
-import java.util.*;
-import java.io.Serializable;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.AbstractCollection;
+import org.jvnet.zephyr.jcl.java.util.AbstractMap;
+import org.jvnet.zephyr.jcl.java.util.AbstractSet;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.HashMap;
+import org.jvnet.zephyr.jcl.java.util.Hashtable;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Map;
+import org.jvnet.zephyr.jcl.java.util.Set;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
 import java.io.IOException;
 import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamField;
+import java.io.Serializable;
+import java.util.ConcurrentModificationException;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;

 /**
  * A hash table supporting full concurrency of retrievals and
  * adjustable expected concurrency for updates. This class obeys the
- * same functional specification as {@link java.util.Hashtable}, and
+ * same functional specification as {@link Hashtable}, and
  * includes versions of methods corresponding to each method of
  * <tt>Hashtable</tt>. However, even though all operations are
  * thread-safe, retrieval operations do <em>not</em> entail locking,
@@ -285,7 +297,7 @@
         static final long nextOffset;
         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = HashEntry.class;
                 nextOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("next"));
@@ -1089,7 +1101,7 @@
      * Legacy method testing if some key maps into the specified value
      * in this table.  This method is identical in functionality to
      * {@link #containsValue}, and exists solely to ensure
-     * full compatibility with class {@link java.util.Hashtable},
+     * full compatibility with class {@link Hashtable},
      * which supported this method prior to introduction of the
      * Java Collections framework.

@@ -1158,8 +1170,11 @@
      * @param m mappings to be stored in this map
      */
     public void putAll(Map<? extends K, ? extends V> m) {
-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> iterator = m.entrySet().iterator();
+                iterator.hasNext(); ) {
+            Map.Entry<? extends K, ? extends V> e = iterator.next();
             put(e.getKey(), e.getValue());
+        }
     }

     /**
@@ -1592,7 +1607,7 @@
     static {
         int ss, ts;
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class tc = HashEntry[].class;
             Class sc = Segment[].class;
             TBASE = UNSAFE.arrayBaseOffset(tc);
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentLinkedDeque.java
--- a/src/share/classes/java/util/concurrent/ConcurrentLinkedDeque.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentLinkedDeque.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,15 +33,17 @@
  * at http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.AbstractCollection;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Deque;
-import java.util.Iterator;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.AbstractCollection;
+import org.jvnet.zephyr.jcl.java.util.ArrayList;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Deque;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Queue;
+
 import java.util.NoSuchElementException;
-import java.util.Queue;

 /**
  * An unbounded concurrent {@linkplain Deque deque} based on linked nodes.
@@ -334,7 +336,7 @@

         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = Node.class;
                 prevOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("prev"));
@@ -848,7 +850,8 @@
     public ConcurrentLinkedDeque(Collection<? extends E> c) {
         // Copy c into a private chain of Nodes
         Node<E> h = null, t = null;
-        for (E e : c) {
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             checkNotNull(e);
             Node<E> newNode = new Node<E>(e);
             if (h == null)
@@ -1157,7 +1160,8 @@

         // Copy c into a private chain of Nodes
         Node<E> beginningOfTheEnd = null, last = null;
-        for (E e : c) {
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             checkNotNull(e);
             Node<E> newNode = new Node<E>(e);
             if (beginningOfTheEnd == null)
@@ -1456,7 +1460,7 @@
         NEXT_TERMINATOR = new Node<Object>();
         NEXT_TERMINATOR.prev = NEXT_TERMINATOR;
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = ConcurrentLinkedDeque.class;
             headOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("head"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentLinkedQueue.java
--- a/src/share/classes/java/util/concurrent/ConcurrentLinkedQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentLinkedQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,14 +33,16 @@
  * at http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.AbstractQueue;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.ArrayList;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Queue;
+
 import java.util.NoSuchElementException;
-import java.util.Queue;

 /**
  * An unbounded thread-safe {@linkplain Queue queue} based on linked nodes.
@@ -207,7 +209,7 @@

         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = Node.class;
                 itemOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("item"));
@@ -266,7 +268,8 @@
      */
     public ConcurrentLinkedQueue(Collection<? extends E> c) {
         Node<E> h = null, t = null;
-        for (E e : c) {
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             checkNotNull(e);
             Node<E> newNode = new Node<E>(e);
             if (h == null)
@@ -520,7 +523,8 @@

         // Copy c into a private chain of Nodes
         Node<E> beginningOfTheEnd = null, last = null;
-        for (E e : c) {
+        for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             checkNotNull(e);
             Node<E> newNode = new Node<E>(e);
             if (beginningOfTheEnd == null)
@@ -822,7 +826,7 @@
     private static final long tailOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = ConcurrentLinkedQueue.class;
             headOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("head"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentMap.java
--- a/src/share/classes/java/util/concurrent/ConcurrentMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,12 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.Map;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.util.Map;

 /**
- * A {@link java.util.Map} providing additional atomic
+ * A {@link Map} providing additional atomic
  * <tt>putIfAbsent</tt>, <tt>remove</tt>, and <tt>replace</tt> methods.
  *
  * <p>Memory consistency effects: As with other concurrent
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentNavigableMap.java
--- a/src/share/classes/java/util/concurrent/ConcurrentNavigableMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentNavigableMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,8 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.util.Collections;
+import org.jvnet.zephyr.jcl.java.util.Comparator;
+import org.jvnet.zephyr.jcl.java.util.NavigableMap;
+import org.jvnet.zephyr.jcl.java.util.NavigableSet;
+
+import java.util.ConcurrentModificationException;

 /**
  * A {@link ConcurrentMap} supporting {@link NavigableMap} operations,
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentSkipListMap.java
--- a/src/share/classes/java/util/concurrent/ConcurrentSkipListMap.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentSkipListMap.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,9 +33,26 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.*;
-import java.util.concurrent.atomic.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.AbstractCollection;
+import org.jvnet.zephyr.jcl.java.util.AbstractMap;
+import org.jvnet.zephyr.jcl.java.util.AbstractSet;
+import org.jvnet.zephyr.jcl.java.util.ArrayList;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Collections;
+import org.jvnet.zephyr.jcl.java.util.Comparator;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.List;
+import org.jvnet.zephyr.jcl.java.util.Map;
+import org.jvnet.zephyr.jcl.java.util.NavigableSet;
+import org.jvnet.zephyr.jcl.java.util.Random;
+import org.jvnet.zephyr.jcl.java.util.Set;
+import org.jvnet.zephyr.jcl.java.util.SortedMap;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * A scalable concurrent {@link ConcurrentNavigableMap} implementation.
@@ -262,7 +279,7 @@
      * do, half have one level, a quarter have two, and so on (see
      * Pugh's Skip List Cookbook, sec 3.4).  The expected total space
      * requirement for a map is slightly less than for the current
-     * implementation of java.util.TreeMap.
+     * implementation of org.jvnet.zephyr.jcl.java.util.TreeMap.
      *
      * Changing the level of the index (i.e, the height of the
      * tree-like structure) also uses CAS. The head index has initial
@@ -516,7 +533,7 @@

         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = Node.class;
                 valueOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("value"));
@@ -596,7 +613,7 @@
         private static final long rightOffset;
         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = Index.class;
                 rightOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("right"));
@@ -1847,10 +1864,13 @@
             return false;
         Map<?,?> m = (Map<?,?>) o;
         try {
-            for (Map.Entry<K,V> e : this.entrySet())
+            for (Iterator<Map.Entry<K, V>> iterator = this.entrySet().iterator(); iterator.hasNext(); ) {
+                Map.Entry<K, V> e = iterator.next();
                 if (! e.getValue().equals(m.get(e.getKey())))
                     return false;
-            for (Map.Entry<?,?> e : m.entrySet()) {
+            }
+            for (Iterator<? extends Map.Entry<?, ?>> iterator = m.entrySet().iterator(); iterator.hasNext(); ) {
+                Map.Entry<?, ?> e = iterator.next();
                 Object k = e.getKey();
                 Object v = e.getValue();
                 if (k == null || v == null || !v.equals(get(k)))
@@ -2297,8 +2317,10 @@
     static final <E> List<E> toList(Collection<E> c) {
         // Using size() here would be a pessimization.
         List<E> list = new ArrayList<E>();
-        for (E e : c)
+        for (Iterator<E> iterator = c.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             list.add(e);
+        }
         return list;
     }

@@ -3108,7 +3130,7 @@
     private static final long headOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = ConcurrentSkipListMap.class;
             headOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("head"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ConcurrentSkipListSet.java
--- a/src/share/classes/java/util/concurrent/ConcurrentSkipListSet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ConcurrentSkipListSet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,9 +33,21 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.*;
-import sun.misc.Unsafe;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.AbstractSet;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Collections;
+import org.jvnet.zephyr.jcl.java.util.Comparator;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Map;
+import org.jvnet.zephyr.jcl.java.util.NavigableSet;
+import org.jvnet.zephyr.jcl.java.util.Set;
+import org.jvnet.zephyr.jcl.java.util.SortedSet;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;

 /**
  * A scalable concurrent {@link NavigableSet} implementation based on
@@ -480,7 +492,7 @@
     private static final long mapOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = ConcurrentSkipListSet.class;
             mapOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("m"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/CopyOnWriteArrayList.java
--- a/src/share/classes/java/util/concurrent/CopyOnWriteArrayList.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/CopyOnWriteArrayList.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,13 +33,24 @@
  * All rights reserved.
  */

-package java.util.concurrent;
-import java.util.*;
-import java.util.concurrent.locks.*;
-import sun.misc.Unsafe;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.AbstractList;
+import org.jvnet.zephyr.jcl.java.util.ArrayList;
+import org.jvnet.zephyr.jcl.java.util.Arrays;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.List;
+import org.jvnet.zephyr.jcl.java.util.ListIterator;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
+import java.util.ConcurrentModificationException;
+import java.util.NoSuchElementException;
+import java.util.RandomAccess;

 /**
- * A thread-safe variant of {@link java.util.ArrayList} in which all mutative
+ * A thread-safe variant of {@link ArrayList} in which all mutative
  * operations (<tt>add</tt>, <tt>set</tt>, and so on) are implemented by
  * making a fresh copy of the underlying array.
  *
@@ -616,7 +627,8 @@
     public boolean containsAll(Collection<?> c) {
         Object[] elements = getArray();
         int len = elements.length;
-        for (Object e : c) {
+        for (Iterator<?> iterator = c.iterator(); iterator.hasNext(); ) {
+            Object e = iterator.next();
             if (indexOf(e, elements, 0, len) < 0)
                 return false;
         }
@@ -1329,7 +1341,7 @@
     private static final long lockOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = CopyOnWriteArrayList.class;
             lockOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("lock"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/CopyOnWriteArraySet.java
--- a/src/share/classes/java/util/concurrent/CopyOnWriteArraySet.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/CopyOnWriteArraySet.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,16 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.util.AbstractSet;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.List;
+import org.jvnet.zephyr.jcl.java.util.Set;

 /**
- * A {@link java.util.Set} that uses an internal {@link CopyOnWriteArrayList}
+ * A {@link Set} that uses an internal {@link CopyOnWriteArrayList}
  * for all of its operations.  Thus, it shares the same basic properties:
  * <ul>
  *  <li>It is best suited for applications in which set sizes generally
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/CountDownLatch.java
--- a/src/share/classes/java/util/concurrent/CountDownLatch.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/CountDownLatch.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,9 +33,10 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.locks.*;
-import java.util.concurrent.atomic.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.AbstractQueuedSynchronizer;

 /**
  * A synchronization aid that allows one or more threads to wait until
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/CyclicBarrier.java
--- a/src/share/classes/java/util/concurrent/CyclicBarrier.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/CyclicBarrier.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,8 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.locks.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Condition;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
+import java.util.concurrent.BrokenBarrierException;
+import java.util.concurrent.TimeoutException;

 /**
  * A synchronization aid that allows a set of threads to all wait for
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/DelayQueue.java
--- a/src/share/classes/java/util/concurrent/DelayQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/DelayQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -34,9 +34,17 @@
  */


-package java.util.concurrent;
-import java.util.concurrent.locks.*;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.PriorityQueue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Condition;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
+import java.util.NoSuchElementException;

 /**
  * An unbounded {@linkplain BlockingQueue blocking queue} of
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/Delayed.java
--- a/src/share/classes/java/util/concurrent/Delayed.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/Delayed.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,9 +33,7 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

 /**
  * A mix-in style interface for marking objects that should be
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/Exchanger.java
--- a/src/share/classes/java/util/concurrent/Exchanger.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/Exchanger.java	Fri Jul 31 15:48:18 2015 +0300
@@ -34,9 +34,17 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.atomic.*;
-import java.util.concurrent.locks.LockSupport;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.Random;
+import org.jvnet.zephyr.jcl.java.util.concurrent.atomic.AtomicInteger;
+import org.jvnet.zephyr.jcl.java.util.concurrent.atomic.AtomicReference;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport;
+import sun.misc.Unsafe;
+
+import java.util.concurrent.TimeoutException;

 /**
  * A synchronization point at which threads can pair and swap elements
@@ -386,7 +394,7 @@
      * <p>To return an index between 0 and max, we use a cheap
      * approximation to a mod operation, that also corrects for bias
      * due to non-power-of-2 remaindering (see {@link
-     * java.util.Random#nextInt}).  Bits of the hashcode are masked
+     * Random#nextInt}).  Bits of the hashcode are masked
      * with "nbits", the ceiling power of two of table size (looked up
      * in a table packed into three ints).  If too large, this is
      * retried after rotating the hash by nbits bits, while forcing new
@@ -399,7 +407,7 @@
      * @return a per-thread-random index, 0 <= index < max
      */
     private final int hashIndex() {
-        long id = Thread.currentThread().getId();
+        long id = getThreadId(Thread.currentThread());
         int hash = (((int)(id ^ (id >>> 32))) ^ 0x811c9dc5) * 0x01000193;

         int m = max.get();
@@ -684,4 +692,19 @@
         }
         throw new InterruptedException();
     }
+
+    private static long getThreadId(Thread thread) {
+        return unsafe.getLongVolatile(thread, TID_OFFSET);
+    }
+
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
+    private static final long TID_OFFSET;
+
+    static {
+        try {
+            TID_OFFSET = unsafe.objectFieldOffset(Thread.class.getDeclaredField("tid"));
+        } catch (NoSuchFieldException e) {
+            throw new Error(e);
+        }
+    }
 }
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/Future.java
--- a/src/share/classes/java/util/concurrent/Future.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/Future.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,12 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeoutException;

 /**
  * A <tt>Future</tt> represents the result of an asynchronous
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/FutureTask.java
--- a/src/share/classes/java/util/concurrent/FutureTask.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/FutureTask.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,8 +33,17 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.locks.LockSupport;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeoutException;

 /**
  * A cancellable asynchronous computation.  This class provides a base
@@ -149,7 +158,10 @@
      * @throws NullPointerException if the runnable is null
      */
     public FutureTask(Runnable runnable, V result) {
-        this.callable = Executors.callable(runnable, result);
+        if (runnable == null) {
+            throw new NullPointerException();
+        }
+        this.callable = new RunnableAdapter<V>(runnable, result);
         this.state = NEW;       // ensure visibility of callable
     }

@@ -466,7 +478,7 @@
     private static final long waitersOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class<?> k = FutureTask.class;
             stateOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("state"));
@@ -479,4 +491,20 @@
         }
     }

+    private static final class RunnableAdapter<T> implements Callable<T> {
+
+        private final Runnable task;
+        private final T result;
+
+        RunnableAdapter(Runnable task, T result) {
+            this.task = task;
+            this.result = result;
+        }
+
+        @Override
+        public T call() {
+            task.run();
+            return result;
+        }
+    }
 }
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/LinkedBlockingDeque.java
--- a/src/share/classes/java/util/concurrent/LinkedBlockingDeque.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/LinkedBlockingDeque.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,14 +33,15 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.AbstractQueue;
-import java.util.Collection;
-import java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Condition;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
 import java.util.NoSuchElementException;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;

 /**
  * An optionally-bounded {@linkplain BlockingDeque blocking deque} based on
@@ -194,7 +195,8 @@
         final ReentrantLock lock = this.lock;
         lock.lock(); // Never contended, but necessary for visibility
         try {
-            for (E e : c) {
+            for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+                E e = iterator.next();
                 if (e == null)
                     throw new NullPointerException();
                 if (!linkLast(new Node<E>(e)))
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/LinkedBlockingQueue.java
--- a/src/share/classes/java/util/concurrent/LinkedBlockingQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/LinkedBlockingQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,14 +33,15 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.AbstractQueue;
-import java.util.Collection;
-import java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.concurrent.atomic.AtomicInteger;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Condition;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
 import java.util.NoSuchElementException;

 /**
@@ -277,7 +278,8 @@
         putLock.lock(); // Never contended, but necessary for visibility
         try {
             int n = 0;
-            for (E e : c) {
+            for (Iterator<? extends E> iterator = c.iterator(); iterator.hasNext(); ) {
+                E e = iterator.next();
                 if (e == null)
                     throw new NullPointerException();
                 if (n == capacity)
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/LinkedTransferQueue.java
--- a/src/share/classes/java/util/concurrent/LinkedTransferQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/LinkedTransferQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,15 +33,17 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.AbstractQueue;
-import java.util.Collection;
-import java.util.Iterator;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.Queue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport;
+
 import java.util.NoSuchElementException;
-import java.util.Queue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.LockSupport;

 /**
  * An unbounded {@link TransferQueue} based on linked nodes.
@@ -541,7 +543,7 @@
         private static final long waiterOffset;
         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = Node.class;
                 itemOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("item"));
@@ -1304,8 +1306,10 @@
     private void writeObject(java.io.ObjectOutputStream s)
         throws java.io.IOException {
         s.defaultWriteObject();
-        for (E e : this)
+        for (Iterator<E> iterator = this.iterator(); iterator.hasNext(); ) {
+            E e = iterator.next();
             s.writeObject(e);
+        }
         // Use trailing null as sentinel
         s.writeObject(null);
     }
@@ -1336,7 +1340,7 @@
     private static final long sweepVotesOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = LinkedTransferQueue.class;
             headOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("head"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/PriorityBlockingQueue.java
--- a/src/share/classes/java/util/concurrent/PriorityBlockingQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/PriorityBlockingQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,22 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.*;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Arrays;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Comparator;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.PriorityQueue;
+import org.jvnet.zephyr.jcl.java.util.Queue;
+import org.jvnet.zephyr.jcl.java.util.SortedSet;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Condition;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;
+
+import java.util.NoSuchElementException;

 /**
  * An unbounded {@linkplain BlockingQueue blocking queue} that uses
@@ -108,7 +119,7 @@
      * postponement of waiting consumers and consequent element
      * build-up. The need to back away from lock during allocation
      * makes it impossible to simply wrap delegated
-     * java.util.PriorityQueue operations within a lock, as was done
+     * org.jvnet.zephyr.jcl.java.util.PriorityQueue operations within a lock, as was done
      * in a previous version of this class. To maintain
      * interoperability, a plain PriorityQueue is still used during
      * serialization, which maintains compatibility at the expense of
@@ -903,7 +914,7 @@
      * Saves this queue to a stream (that is, serializes it).
      *
      * For compatibility with previous version of this class, elements
-     * are first copied to a java.util.PriorityQueue, which is then
+     * are first copied to a org.jvnet.zephyr.jcl.java.util.PriorityQueue, which is then
      * serialized.
      */
     private void writeObject(java.io.ObjectOutputStream s)
@@ -940,7 +951,7 @@
     private static final long allocationSpinLockOffset;
     static {
         try {
-            UNSAFE = sun.misc.Unsafe.getUnsafe();
+            UNSAFE = UnsafeHolder.getUnsafe();
             Class k = PriorityBlockingQueue.class;
             allocationSpinLockOffset = UNSAFE.objectFieldOffset
                 (k.getDeclaredField("allocationSpinLock"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/RunnableFuture.java
--- a/src/share/classes/java/util/concurrent/RunnableFuture.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/RunnableFuture.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,9 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import java.util.concurrent.Executor;

 /**
  * A {@link Future} that is {@link Runnable}. Successful execution of
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/Semaphore.java
--- a/src/share/classes/java/util/concurrent/Semaphore.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/Semaphore.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,10 +33,12 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.*;
-import java.util.concurrent.locks.*;
-import java.util.concurrent.atomic.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.AbstractQueuedSynchronizer;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Lock;

 /**
  * A counting semaphore.  Conceptually, a semaphore maintains a set of
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/SynchronousQueue.java
--- a/src/share/classes/java/util/concurrent/SynchronousQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/SynchronousQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -34,10 +34,16 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
-import java.util.concurrent.locks.*;
-import java.util.concurrent.atomic.*;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.AbstractQueue;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Collections;
+import org.jvnet.zephyr.jcl.java.util.Iterator;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.LockSupport;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.ReentrantLock;

 /**
  * A {@linkplain BlockingQueue blocking queue} in which each insert
@@ -285,7 +291,7 @@

             static {
                 try {
-                    UNSAFE = sun.misc.Unsafe.getUnsafe();
+                    UNSAFE = UnsafeHolder.getUnsafe();
                     Class k = SNode.class;
                     matchOffset = UNSAFE.objectFieldOffset
                         (k.getDeclaredField("match"));
@@ -512,7 +518,7 @@
         private static final long headOffset;
         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = TransferStack.class;
                 headOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("head"));
@@ -582,7 +588,7 @@

             static {
                 try {
-                    UNSAFE = sun.misc.Unsafe.getUnsafe();
+                    UNSAFE = UnsafeHolder.getUnsafe();
                     Class k = QNode.class;
                     itemOffset = UNSAFE.objectFieldOffset
                         (k.getDeclaredField("item"));
@@ -826,7 +832,7 @@
         private static final long cleanMeOffset;
         static {
             try {
-                UNSAFE = sun.misc.Unsafe.getUnsafe();
+                UNSAFE = UnsafeHolder.getUnsafe();
                 Class k = TransferQueue.class;
                 headOffset = UNSAFE.objectFieldOffset
                     (k.getDeclaredField("head"));
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/ThreadLocalRandom.java
--- a/src/share/classes/java/util/concurrent/ThreadLocalRandom.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/ThreadLocalRandom.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,13 +33,16 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

-import java.util.Random;
+import org.jvnet.zephyr.jcl.java.lang.ThreadLocal;
+import org.jvnet.zephyr.jcl.java.util.Random;
+
+import java.util.concurrent.ForkJoinTask;

 /**
  * A random number generator isolated to the current thread.  Like the
- * global {@link java.util.Random} generator used by the {@link
+ * global {@link Random} generator used by the {@link
  * java.lang.Math} class, a {@code ThreadLocalRandom} is initialized
  * with an internally generated seed that may not otherwise be
  * modified. When applicable, use of {@code ThreadLocalRandom} rather
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/TimeUnit.java
--- a/src/share/classes/java/util/concurrent/TimeUnit.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/TimeUnit.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,10 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.locks.Lock;

 /**
  * A <tt>TimeUnit</tt> represents time durations at a given unit of
@@ -50,7 +53,7 @@
  * <p>A <tt>TimeUnit</tt> is mainly used to inform time-based methods
  * how a given timing parameter should be interpreted. For example,
  * the following code will timeout in 50 milliseconds if the {@link
- * java.util.concurrent.locks.Lock lock} is not available:
+ * Lock lock} is not available:
  *
  * <pre>  Lock lock = ...;
  *  if (lock.tryLock(50L, TimeUnit.MILLISECONDS)) ...
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/TransferQueue.java
--- a/src/share/classes/java/util/concurrent/TransferQueue.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/TransferQueue.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,7 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent;
+package org.jvnet.zephyr.jcl.java.util.concurrent;

 /**
  * A {@link BlockingQueue} in which producers may wait for consumers
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicInteger.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicInteger.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicInteger.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,12 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;

 /**
  * An {@code int} value that may be updated atomically.  See the
- * {@link java.util.concurrent.atomic} package specification for
+ * {@link org.jvnet.zephyr.jcl.java.util.concurrent.atomic} package specification for
  * description of the properties of atomic variables. An
  * {@code AtomicInteger} is used in applications such as atomically
  * incremented counters, and cannot be used as a replacement for an
@@ -53,7 +55,7 @@
     private static final long serialVersionUID = 6214790243416807050L;

     // setup to use Unsafe.compareAndSwapInt for updates
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long valueOffset;

     static {
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,13 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;
-import java.util.*;

 /**
  * An {@code int} array in which elements may be updated atomically.
- * See the {@link java.util.concurrent.atomic} package
+ * See the {@link org.jvnet.zephyr.jcl.java.util.concurrent.atomic} package
  * specification for description of the properties of atomic
  * variables.
  * @since 1.5
@@ -48,7 +49,7 @@
 public class AtomicIntegerArray implements java.io.Serializable {
     private static final long serialVersionUID = 2862133569453604235L;

-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final int base = unsafe.arrayBaseOffset(int[].class);
     private static final int shift;
     private final int[] array;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
-import java.lang.reflect.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.ReflectionUtils;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;
-import sun.reflect.CallerSensitive;
-import sun.reflect.Reflection;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;

 /**
  * A reflection-based utility that enables atomic updates to
@@ -71,9 +74,8 @@
      * @throws RuntimeException with a nested reflection-based
      * exception if the class does not hold field or is the wrong type
      */
-    @CallerSensitive
     public static <U> AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass, String fieldName) {
-        return new AtomicIntegerFieldUpdaterImpl<U>(tclass, fieldName, Reflection.getCallerClass());
+        return new AtomicIntegerFieldUpdaterImpl<U>(tclass, fieldName, ReflectionUtils.getClassContext()[3]);
     }

     /**
@@ -266,7 +268,7 @@
      * Standard hotspot implementation using intrinsics
      */
     private static class AtomicIntegerFieldUpdaterImpl<T> extends AtomicIntegerFieldUpdater<T> {
-        private static final Unsafe unsafe = Unsafe.getUnsafe();
+        private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
         private final long offset;
         private final Class<T> tclass;
         private final Class cclass;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicLong.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicLong.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicLong.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,12 +33,16 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;

+import java.lang.reflect.Field;
+
 /**
  * A {@code long} value that may be updated atomically.  See the
- * {@link java.util.concurrent.atomic} package specification for
+ * {@link org.jvnet.zephyr.jcl.java.util.concurrent.atomic} package specification for
  * description of the properties of atomic variables. An
  * {@code AtomicLong} is used in applications such as atomically
  * incremented sequence numbers, and cannot be used as a replacement
@@ -53,7 +57,7 @@
     private static final long serialVersionUID = 1927816293512124184L;

     // setup to use Unsafe.compareAndSwapLong for updates
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long valueOffset;

     /**
@@ -62,13 +66,17 @@
      * method works in either case, some constructions should be
      * handled at Java level to avoid locking user-visible locks.
      */
-    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();
+    static final boolean VM_SUPPORTS_LONG_CAS;

-    /**
-     * Returns whether underlying JVM supports lockless CompareAndSet
-     * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.
-     */
-    private static native boolean VMSupportsCS8();
+    static {
+        try {
+            Field field = java.util.concurrent.atomic.AtomicLong.class.getDeclaredField("VM_SUPPORTS_LONG_CAS");
+            field.setAccessible(true);
+            VM_SUPPORTS_LONG_CAS = field.getBoolean(null);
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }

     static {
       try {
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicLongArray.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicLongArray.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicLongArray.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,13 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;
-import java.util.*;

 /**
  * A {@code long} array in which elements may be updated atomically.
- * See the {@link java.util.concurrent.atomic} package specification
+ * See the {@link org.jvnet.zephyr.jcl.java.util.concurrent.atomic} package specification
  * for description of the properties of atomic variables.
  * @since 1.5
  * @author Doug Lea
@@ -47,7 +48,7 @@
 public class AtomicLongArray implements java.io.Serializable {
     private static final long serialVersionUID = -2308431214976778248L;

-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final int base = unsafe.arrayBaseOffset(long[].class);
     private static final int shift;
     private final long[] array;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
-import java.lang.reflect.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.ReflectionUtils;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;
-import sun.reflect.CallerSensitive;
-import sun.reflect.Reflection;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;

 /**
  * A reflection-based utility that enables atomic updates to
@@ -71,9 +74,8 @@
      * @throws RuntimeException with a nested reflection-based
      * exception if the class does not hold field or is the wrong type.
      */
-    @CallerSensitive
     public static <U> AtomicLongFieldUpdater<U> newUpdater(Class<U> tclass, String fieldName) {
-        Class<?> caller = Reflection.getCallerClass();
+        Class<?> caller = ReflectionUtils.getClassContext()[3];
         if (AtomicLong.VM_SUPPORTS_LONG_CAS)
             return new CASUpdater<U>(tclass, fieldName, caller);
         else
@@ -266,7 +268,7 @@
     }

     private static class CASUpdater<T> extends AtomicLongFieldUpdater<T> {
-        private static final Unsafe unsafe = Unsafe.getUnsafe();
+        private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
         private final long offset;
         private final Class<T> tclass;
         private final Class cclass;
@@ -347,7 +349,7 @@


     private static class LockedUpdater<T> extends AtomicLongFieldUpdater<T> {
-        private static final Unsafe unsafe = Unsafe.getUnsafe();
+        private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
         private final long offset;
         private final Class<T> tclass;
         private final Class cclass;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicReference.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicReference.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicReference.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,12 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;

 /**
  * An object reference that may be updated atomically. See the {@link
- * java.util.concurrent.atomic} package specification for description
+ * org.jvnet.zephyr.jcl.java.util.concurrent.atomic} package specification for description
  * of the properties of atomic variables.
  * @since 1.5
  * @author Doug Lea
@@ -47,7 +49,7 @@
 public class AtomicReference<V>  implements java.io.Serializable {
     private static final long serialVersionUID = -1848883965231344442L;

-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long valueOffset;

     static {
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,15 +33,17 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.util.Arrays;
+import sun.misc.Unsafe;

 import java.lang.reflect.Array;
-import java.util.Arrays;
-import sun.misc.Unsafe;

 /**
  * An array of object references in which elements may be updated
- * atomically.  See the {@link java.util.concurrent.atomic} package
+ * atomically.  See the {@link org.jvnet.zephyr.jcl.java.util.concurrent.atomic} package
  * specification for description of the properties of atomic
  * variables.
  * @since 1.5
@@ -60,7 +62,7 @@
     static {
         int scale;
         try {
-            unsafe = Unsafe.getUnsafe();
+            unsafe = UnsafeHolder.getUnsafe();
             arrayFieldOffset = unsafe.objectFieldOffset
                 (AtomicReferenceArray.class.getDeclaredField("array"));
             base = unsafe.arrayBaseOffset(Object[].class);
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java
--- a/src/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,11 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.atomic;
-import java.lang.reflect.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.atomic;
+
+import org.jvnet.zephyr.jcl.impl.misc.ReflectionUtils;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
 import sun.misc.Unsafe;
-import sun.reflect.CallerSensitive;
-import sun.reflect.Reflection;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;

 /**
  * A reflection-based utility that enables atomic updates to
@@ -90,12 +93,11 @@
      * @throws RuntimeException with a nested reflection-based
      * exception if the class does not hold field or is the wrong type.
      */
-    @CallerSensitive
     public static <U, W> AtomicReferenceFieldUpdater<U,W> newUpdater(Class<U> tclass, Class<W> vclass, String fieldName) {
         return new AtomicReferenceFieldUpdaterImpl<U,W>(tclass,
                                                         vclass,
                                                         fieldName,
-                                                        Reflection.getCallerClass());
+                                                        ReflectionUtils.getClassContext()[3]);
     }

     /**
@@ -183,7 +185,7 @@

     private static final class AtomicReferenceFieldUpdaterImpl<T,V>
         extends AtomicReferenceFieldUpdater<T,V> {
-        private static final Unsafe unsafe = Unsafe.getUnsafe();
+        private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
         private final long offset;
         private final Class<T> tclass;
         private final Class<V> vclass;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/AbstractOwnableSynchronizer.java
--- a/src/share/classes/java/util/concurrent/locks/AbstractOwnableSynchronizer.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/AbstractOwnableSynchronizer.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,9 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;

 /**
  * A synchronizer that may be exclusively owned by a thread.  This
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
--- a/src/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,12 +33,17 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.ArrayList;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.concurrent.TimeUnit;
 import sun.misc.Unsafe;

+import java.util.Date;
+
 /**
  * A version of {@link AbstractQueuedSynchronizer} in
  * which synchronization state is maintained as a <tt>long</tt>.
@@ -2051,7 +2056,7 @@
      * are at it, we do the same for other CASable fields (which could
      * otherwise be done with atomic field updaters).
      */
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long stateOffset;
     private static final long headOffset;
     private static final long tailOffset;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
--- a/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,12 +33,19 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.ArrayList;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.Queue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.CountDownLatch;
+import org.jvnet.zephyr.jcl.java.util.concurrent.TimeUnit;
 import sun.misc.Unsafe;

+import java.util.Date;
+
 /**
  * Provides a framework for implementing blocking locks and related
  * synchronizers (semaphores, events, etc) that rely on
@@ -180,8 +187,8 @@
  * synchronizers that can rely on <tt>int</tt> state, acquire, and
  * release parameters, and an internal FIFO wait queue. When this does
  * not suffice, you can build synchronizers from a lower level using
- * {@link java.util.concurrent.atomic atomic} classes, your own custom
- * {@link java.util.Queue} classes, and {@link LockSupport} blocking
+ * {@link org.jvnet.zephyr.jcl.java.util.concurrent.atomic atomic} classes, your own custom
+ * {@link Queue} classes, and {@link LockSupport} blocking
  * support.
  *
  * <h3>Usage Examples</h3>
@@ -2272,7 +2279,7 @@
      * are at it, we do the same for other CASable fields (which could
      * otherwise be done with atomic field updaters).
      */
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long stateOffset;
     private static final long headOffset;
     private static final long tailOffset;
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/Condition.java
--- a/src/share/classes/java/util/concurrent/locks/Condition.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/Condition.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,8 +33,12 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.concurrent.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.ArrayBlockingQueue;
+import org.jvnet.zephyr.jcl.java.util.concurrent.TimeUnit;
+
 import java.util.Date;

 /**
@@ -111,7 +115,7 @@
  * }
  * </pre>
  *
- * (The {@link java.util.concurrent.ArrayBlockingQueue} class provides
+ * (The {@link ArrayBlockingQueue} class provides
  * this functionality, so there is no reason to implement this
  * sample usage class.)
  *
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/Lock.java
--- a/src/share/classes/java/util/concurrent/locks/Lock.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/Lock.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,8 +33,10 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.concurrent.TimeUnit;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.TimeUnit;

 /**
  * {@code Lock} implementations provide more extensive locking
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/LockSupport.java
--- a/src/share/classes/java/util/concurrent/locks/LockSupport.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/LockSupport.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,17 +33,23 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.concurrent.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.impl.misc.SharedSecrets;
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.concurrent.Semaphore;
 import sun.misc.Unsafe;

+import java.util.concurrent.TimeUnit;
+

 /**
  * Basic thread blocking primitives for creating locks and other
  * synchronization classes.
  *
  * <p>This class associates, with each thread that uses it, a permit
- * (in the sense of the {@link java.util.concurrent.Semaphore
+ * (in the sense of the {@link Semaphore
  * Semaphore} class). A call to {@code park} will return immediately
  * if the permit is available, consuming it in the process; otherwise
  * it <em>may</em> block.  A call to {@code unpark} makes the permit
@@ -121,13 +127,13 @@
     private LockSupport() {} // Cannot be instantiated.

     // Hotspot implementation via intrinsics API
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
     private static final long parkBlockerOffset;

     static {
         try {
             parkBlockerOffset = unsafe.objectFieldOffset
-                (java.lang.Thread.class.getDeclaredField("parkBlocker"));
+                (Thread.class.getDeclaredField("parkBlocker"));
         } catch (Exception ex) { throw new Error(ex); }
     }

@@ -149,7 +155,7 @@
      */
     public static void unpark(Thread thread) {
         if (thread != null)
-            unsafe.unpark(thread);
+            SharedSecrets.getThreadAccess().getImpl(thread).unpark();
     }

     /**
@@ -183,7 +189,7 @@
     public static void park(Object blocker) {
         Thread t = Thread.currentThread();
         setBlocker(t, blocker);
-        unsafe.park(false, 0L);
+        SharedSecrets.getThreadAccess().getImpl(Thread.currentThread()).park();
         setBlocker(t, null);
     }

@@ -223,7 +229,7 @@
         if (nanos > 0) {
             Thread t = Thread.currentThread();
             setBlocker(t, blocker);
-            unsafe.park(false, nanos);
+            SharedSecrets.getThreadAccess().getImpl(Thread.currentThread()).park(nanos, TimeUnit.NANOSECONDS);
             setBlocker(t, null);
         }
     }
@@ -264,7 +270,7 @@
     public static void parkUntil(Object blocker, long deadline) {
         Thread t = Thread.currentThread();
         setBlocker(t, blocker);
-        unsafe.park(true, deadline);
+        SharedSecrets.getThreadAccess().getImpl(Thread.currentThread()).parkUntil(deadline);
         setBlocker(t, null);
     }

@@ -312,7 +318,7 @@
      * for example, the interrupt status of the thread upon return.
      */
     public static void park() {
-        unsafe.park(false, 0L);
+        SharedSecrets.getThreadAccess().getImpl(Thread.currentThread()).park();
     }

     /**
@@ -346,7 +352,7 @@
      */
     public static void parkNanos(long nanos) {
         if (nanos > 0)
-            unsafe.park(false, nanos);
+            SharedSecrets.getThreadAccess().getImpl(Thread.currentThread()).park(nanos, TimeUnit.NANOSECONDS);
     }

     /**
@@ -380,6 +386,6 @@
      *        to wait until
      */
     public static void parkUntil(long deadline) {
-        unsafe.park(true, deadline);
+        SharedSecrets.getThreadAccess().getImpl(Thread.currentThread()).parkUntil(deadline);
     }
 }
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/ReadWriteLock.java
--- a/src/share/classes/java/util/concurrent/locks/ReadWriteLock.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/ReadWriteLock.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,7 +33,7 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;

 /**
  * A <tt>ReadWriteLock</tt> maintains a pair of associated {@link
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/ReentrantLock.java
--- a/src/share/classes/java/util/concurrent/locks/ReentrantLock.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/ReentrantLock.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,10 +33,11 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.concurrent.TimeUnit;

 /**
  * A reentrant mutual exclusion {@link Lock} with the same basic
diff -r 55f6804b4352 src/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java
--- a/src/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java	Tue Apr 14 13:48:05 2015 -0700
+++ b/src/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java	Fri Jul 31 15:48:18 2015 +0300
@@ -33,10 +33,14 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */

-package java.util.concurrent.locks;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.*;
-import java.util.*;
+package org.jvnet.zephyr.jcl.java.util.concurrent.locks;
+
+import org.jvnet.zephyr.jcl.impl.misc.UnsafeHolder;
+import org.jvnet.zephyr.jcl.java.lang.Thread;
+import org.jvnet.zephyr.jcl.java.lang.ThreadLocal;
+import org.jvnet.zephyr.jcl.java.util.Collection;
+import org.jvnet.zephyr.jcl.java.util.concurrent.TimeUnit;
+import sun.misc.Unsafe;

 /**
  * An implementation of {@link ReadWriteLock} supporting similar
@@ -279,7 +283,7 @@
         static final class HoldCounter {
             int count = 0;
             // Use id, not reference, to avoid garbage retention
-            final long tid = Thread.currentThread().getId();
+            final long tid = getThreadId(Thread.currentThread());
         }

         /**
@@ -422,7 +426,7 @@
                     firstReaderHoldCount--;
             } else {
                 HoldCounter rh = cachedHoldCounter;
-                if (rh == null || rh.tid != current.getId())
+                if (rh == null || rh.tid != getThreadId(current))
                     rh = readHolds.get();
                 int count = rh.count;
                 if (count <= 1) {
@@ -480,7 +484,7 @@
                     firstReaderHoldCount++;
                 } else {
                     HoldCounter rh = cachedHoldCounter;
-                    if (rh == null || rh.tid != current.getId())
+                    if (rh == null || rh.tid != getThreadId(current))
                         cachedHoldCounter = rh = readHolds.get();
                     else if (rh.count == 0)
                         readHolds.set(rh);
@@ -517,7 +521,7 @@
                     } else {
                         if (rh == null) {
                             rh = cachedHoldCounter;
-                            if (rh == null || rh.tid != current.getId()) {
+                            if (rh == null || rh.tid != getThreadId(current)) {
                                 rh = readHolds.get();
                                 if (rh.count == 0)
                                     readHolds.remove();
@@ -538,7 +542,7 @@
                     } else {
                         if (rh == null)
                             rh = cachedHoldCounter;
-                        if (rh == null || rh.tid != current.getId())
+                        if (rh == null || rh.tid != getThreadId(current))
                             rh = readHolds.get();
                         else if (rh.count == 0)
                             readHolds.set(rh);
@@ -594,7 +598,7 @@
                         firstReaderHoldCount++;
                     } else {
                         HoldCounter rh = cachedHoldCounter;
-                        if (rh == null || rh.tid != current.getId())
+                        if (rh == null || rh.tid != getThreadId(current))
                             cachedHoldCounter = rh = readHolds.get();
                         else if (rh.count == 0)
                             readHolds.set(rh);
@@ -645,7 +649,7 @@
                 return firstReaderHoldCount;

             HoldCounter rh = cachedHoldCounter;
-            if (rh != null && rh.tid == current.getId())
+            if (rh != null && rh.tid == getThreadId(current))
                 return rh.count;

             int count = readHolds.get().count;
@@ -1483,4 +1487,18 @@
             "[Write locks = " + w + ", Read locks = " + r + "]";
     }

+    private static long getThreadId(Thread thread) {
+        return unsafe.getLongVolatile(thread, TID_OFFSET);
+    }
+
+    private static final Unsafe unsafe = UnsafeHolder.getUnsafe();
+    private static final long TID_OFFSET;
+
+    static {
+        try {
+            TID_OFFSET = unsafe.objectFieldOffset(Thread.class.getDeclaredField("tid"));
+        } catch (NoSuchFieldException e) {
+            throw new Error(e);
+        }
+    }
 }
